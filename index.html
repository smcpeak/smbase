<!DOCTYPE html>
<HTML lang="en">

<HEAD>
  <TITLE>smbase</TITLE>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <style>
    H1 { font-size: 150% }
    H2 { font-size: 125% }
    H3 { font-size: 100% }
    P.title {
      font-size: 175%;
      text-align: center;
    }
    dl {
      padding-left: 1.5em;
    }
  </style>
</HEAD>

<body>

<p class="title"><b>smbase: A Utility Library</b></p>

<h1>Introduction</h1>

<p>
"smbase" stands for Scott McPeak's Base Library (sorry, naming things
is not my specialty).  It's a bunch of
utility modules I use in virtually all of my projects.  The entire
library is in the public domain.

<p>
There is some overlap in functionality between smbase and the C++
Standard Library.  Partly this is because smbase predates the standard
library, and partly this is due to my disagreement with certain aspects
of the standard library design (although the relevance of those
disagreements has diminished with time).  My intent, going forward, is
to use standard library facilities when possible.

<p>
smbase has developed organically, in response to specific needs.
While each module individually has been reasonably carefully designed,
the library as a whole has not.  Consequently, the modules to not
always orthogonally cover a given design space, and some of the
modules are now considered obsolete (marked below as such).


<h1>Build Instructions</h1>

<p>
<pre>
  $ ./configure
  $ make
  $ make check
</pre>

<p>
<a href="configure"><code>./configure</code></a> does nothing, but exists
for consistency with other packages.

<p>
Configuration is done by creating an optional <code>config.mk</code>
file and, in that file, setting variables that are described at the top
of <a href="Makefile"><code>Makefile</code></a>.


<h1>Modules</h1>

<p>
The following sections list all the smbase modules, grouped by
functionality.


<h2>Linked Lists</h2>

<p>
Linked lists are sequences of objects with O(1) insertion at the front
and iterators for traversal.  Most also have <em>mutators</em> for
traversing and modifying.

<p>
There are a couple of variants that support O(1) appending:

<dl>

<!-- begin header: vdtllist.h -->
  <!-- AUTO --><dt><a href="vdtllist.h">vdtllist.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  List of void*, with a pointer maintained to the last (tail)
  <!-- AUTO -->  element, for constant-time append.  Used by ASTList and VoidTailList.
<!-- end header -->

<!-- begin header: taillist.h -->
  <!-- AUTO --><dt><a href="taillist.h">taillist.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  List wrapper around VoidTailList, like ASTList, but it doesn't own
  <!-- AUTO -->  the elements.
<!-- end header -->

<!-- begin header: astlist.h -->
  <!-- AUTO --><dt><a href="astlist.h">astlist.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  ASTList, a list class for use in abstract syntax trees.
  <!-- AUTO -->  Owner list wrapper around VoidTailList.
  <!-- AUTO -->  The name 'AST' is because the first application is in ASTs.
<!-- end header -->

</dl>

<p>
The remainder of this section is obsolete, with
<code>std::list</code>, possibly in combination with
<code>std::unique_ptr</code>, replacing it.

<dl>

<!-- begin header: objlist.h -->
  <!-- AUTO --><dt><a href="objlist.h">objlist.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  Owner list of arbitrary dynamically-allocated objects.
  <!-- AUTO -->  NOTE: automatically generated from xobjlist.h -- do not edit directly
<!-- end header -->

<!-- begin header: sobjlist.h -->
  <!-- AUTO --><dt><a href="sobjlist.h">sobjlist.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  Serf (non-owning) list of arbitrary objects.
  <!-- AUTO -->  NOTE: automatically generated from xobjlist.h -- do not edit directly
<!-- end header -->

<!-- begin header: xobjlist.h -->
  <!-- AUTO --><dt><a href="xobjlist.h">xobjlist.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  Template file to be processed with m4 to generate one
  <!-- AUTO -->  of the wrappers around VoidList.
<!-- end header -->

<!-- begin header: voidlist.h -->
  <!-- AUTO --><dt><a href="voidlist.h">voidlist.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  List of void*.  This is used by ObjList and SObjList.
<!-- end header -->

<!-- begin header: objstack.h -->
  <!-- AUTO --><dt><a href="objstack.h">objstack.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  ObjStack, a stack of owned objects.  Built with a linked list.
<!-- end header -->

<!-- begin header: sobjstack.h -->
  <!-- AUTO --><dt><a href="sobjstack.h">sobjstack.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  SObjStack, a stack of non-owned objects.  Built with a linked list.
<!-- end header -->

</dl>


<h2>Arrays</h2>

<p>
Arrays are sequences of objects with O(1) random access and replacement.

<p>
Everything in this section is obsoleted by <code>std::vector</code>.

<dl>

<!-- begin header: array.h -->
  <!-- AUTO --><dt><a href="array.h">array.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  Several array-like template classes, including growable arrays.
<!-- end header -->

<!-- begin header: bitwise_array.h -->
  <!-- AUTO --><dt><a href="bitwise_array.h">bitwise_array.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  Some array classes that use bitwise copying when expanding.
<!-- end header -->

<!-- begin header: arrayqueue.h -->
  <!-- AUTO --><dt><a href="arrayqueue.h">arrayqueue.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  ArrayQueue, a template class implementing a queue with an array.
  <!-- AUTO -->  Supports O(1) enqueue and dequeue.
<!-- end header -->

<!-- begin header: datablok.h -->
  <!-- AUTO --><dt><a href="datablok.h">datablok.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  DataBlock, an array of characters of a given length.  Useful when the
  <!-- AUTO -->  data may contain NUL ('\0') bytes.
<!-- end header -->

<!-- begin header: growbuf.h -->
  <!-- AUTO --><dt><a href="growbuf.h">growbuf.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  Extension of DataBlock that provides an append() function.
<!-- end header -->

<!-- begin header: arraymap.h -->
  <!-- AUTO --><dt><a href="arraymap.h">arraymap.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  ArrayMap, a map from integers to owner object pointers. Obsolete.
<!-- end header -->


</dl>


<h2>Arrays of Bits</h2>

<p>
Arrays of bits are handled specially, because they are implemented by
storing multiple bits per byte.

<dl>

<!-- begin header: bit2d.h -->
  <!-- AUTO --><dt><a href="bit2d.h">bit2d.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  Two-dimensional array of bits.
<!-- end header -->

<!-- begin header: bitarray.h -->
  <!-- AUTO --><dt><a href="bitarray.h">bitarray.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  One-dimensional array of bits.
<!-- end header -->

</dl>


<h2>Hash Tables and Maps</h2>

<p>
Maps support mapping from arbitrary domains to arbitrary ranges.  Mappings
can be added and queried in amortized O(1) time, but the constant factor
is considerably higher than for arrays and lists.

<p>
Everything in this section is obsoleted by <code>std::map</code>,
possibly in combination with <code>std::unique_ptr</code>, and perhaps
<code>std::unordered_map</code> in some cases.

<p>
Probably the most common map is the PtrMap template, which will map
from pointers to pointers, for arbitrary pointed-to types.

<dl>

<!-- begin header: ptrmap.h -->
  <!-- AUTO --><dt><a href="ptrmap.h">ptrmap.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  PtrMap, a non-owning template class built on top of VoidPtrMap.
<!-- end header -->

<!-- begin header: objmap.h -->
  <!-- AUTO --><dt><a href="objmap.h">objmap.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  ObjMap, a PtrMap where the values (but not keys) are owned.
<!-- end header -->

<!-- begin header: vptrmap.h -->
  <!-- AUTO --><dt><a href="vptrmap.h">vptrmap.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  Hashtable-based map from void* to void*.
  <!-- AUTO -->  Used by ptrmap.h and objmap.h.
<!-- end header -->

</dl>

<p>
If the key can always be derived from the data (for example, the key
is stored in the data object), then it is inefficient to store both in
the table.  The following variants require a function pointer to map
from data to keys.

<dl>

<!-- begin header: hashtbl.h -->
  <!-- AUTO --><dt><a href="hashtbl.h">hashtbl.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  Hash table mapping arbitrary keys to void*, where
  <!-- AUTO -->  the stored pointers can be used to derive the key,
  <!-- AUTO -->  and cannot be NULL.
<!-- end header -->

<!-- begin header: thashtbl.h -->
  <!-- AUTO --><dt><a href="thashtbl.h">thashtbl.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  Template class built on top of HashTable.  Maps KEY* to VALUE*.
<!-- end header -->

<!-- begin header: ohashtbl.h -->
  <!-- AUTO --><dt><a href="ohashtbl.h">ohashtbl.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  OwnerHashTable, a hash table that owns the values.  Maps void* to T*.
<!-- end header -->

</dl>

<p>
The above can be used to efficiently implement a set of T*.

<dl>

<!-- begin header: sobjset.h -->
  <!-- AUTO --><dt><a href="sobjset.h">sobjset.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  SObjSet, a non-owning set of objects implemented on top of HashTable.
<!-- end header -->

</dl>

<p>
There are two specialized versions that combine O(1) insertion
and query of a hash table with O(1) enqueue and dequeue of an
array.

<dl>

<!-- begin header: okhasharr.h -->
  <!-- AUTO --><dt><a href="okhasharr.h">okhasharr.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  OwnerKHashArray, a combination of an owner hash table and an array/stack.
<!-- end header -->

<!-- begin header: okhashtbl.h -->
  <!-- AUTO --><dt><a href="okhashtbl.h">okhashtbl.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  OwnerKHashTable, a version of okhasharr.h with type-safe keys ("k" for keys).
<!-- end header -->

</dl>


<h2>Maps with Strings as Keys</h2>

<p>
Mapping from strings is a nontrivial extension of the above maps
because comparison is more than a pointer equality test.  So there
are some specialized maps from strings.

<p>
Everything in this section is obsolete, as it can be done using standard
library maps and an appropriate comparator.

<p>
If you have a function that can map from data to (string) key,
then StringHash and TStringHash (the template version) are the
most efficient:

<dl>

<!-- begin header: strhash.h -->
  <!-- AUTO --><dt><a href="strhash.h">strhash.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  Hash table mapping strings to arbitrary pointers, where
  <!-- AUTO -->  the stored pointers can be used to derive the key, and
  <!-- AUTO -->  cannot be NULL.
<!-- end header -->

</dl>

<p>
The StringVoidDict and templates wrapped around it are more general.
They do not require a function to map from data to key, support
query-then-modify-result, and alphabetic iteration.

<dl>

<!-- begin header: strobjdict.h -->
  <!-- AUTO --><dt><a href="strobjdict.h">strobjdict.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  StringObjDict, a case-sensitive map from strings to object pointers.
  <!-- AUTO -->  The dictionary owns the referred-to objects.
<!-- end header -->

<!-- begin header: strsobjdict.h -->
  <!-- AUTO --><dt><a href="strsobjdict.h">strsobjdict.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  StringSObjDict, a case-sensitive map from strings to object pointers.
  <!-- AUTO -->  The dictionary does *not* own the referred-to objects.
<!-- end header -->

<!-- begin header: strintdict.h -->
  <!-- AUTO --><dt><a href="strintdict.h">strintdict.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  Dictionary of intptr_t (integers that fit into void*), indexed by string
  <!-- AUTO -->  (case-sensitive).
<!-- end header -->

<!-- begin header: xstrobjdict.h -->
  <!-- AUTO --><dt><a href="xstrobjdict.h">xstrobjdict.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  Template file to be processed with m4 to generate one
  <!-- AUTO -->  of the wrappers around StringVoidDict.
<!-- end header -->

<!-- begin header: svdict.h -->
  <!-- AUTO --><dt><a href="svdict.h">svdict.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  StringVoidDict, a case-sensitive map from strings to void* pointers.
  <!-- AUTO -->  Built on top of StringHash.
<!-- end header -->

</dl>

<p>
Finally, there is a module to map from strings to strings.

<dl>

<!-- begin header: strdict.h -->
  <!-- AUTO --><dt><a href="strdict.h">strdict.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  StringDict, a case-sensitive map from strings to strings.
  <!-- AUTO -->  Currently, this is implemented with a linked list and consequently
  <!-- AUTO -->  not efficient.  But it will work when efficiency does not matter,
  <!-- AUTO -->  and could be reimplemented (preserving the interface) with something
  <!-- AUTO -->  better.
<!-- end header -->

</dl>


<h2>Strings</h2>

<p>
Strings are sequences of characters.

<p>
These two modules still have some utility, although they currently are
still based on the obsolete <code>str</code> module:

<dl>

<!-- begin header: strtokp.h -->
  <!-- AUTO --><dt><a href="strtokp.h">strtokp.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  StrtokParse, a class that parses a string similar to how strtok()
  <!-- AUTO -->  works, but provides a more convenient (and thread-safe) interface.
  <!-- AUTO -->  Similar to Java's StringTokenizer.
<!-- end header -->

<!-- begin header: strutil.h -->
  <!-- AUTO --><dt><a href="strutil.h">strutil.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  A set of generic string utilities, including replace(), translate(),
  <!-- AUTO -->  trimWhitespace(), encodeWithEscapes(), etc.
<!-- end header -->

</dl>

All of these are obsolete:

<dl>

<!-- begin header: str.h -->
  <!-- AUTO --><dt><a href="str.h">str.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  A string class.
  <!-- AUTO --><br><br>
  <!-- AUTO -->  2024-05-18: I renamed 'string' to 'OldSmbaseString'.  The transition
  <!-- AUTO -->  plan now, simply, is to replace occurrences of 'OldSmbaseString' with
  <!-- AUTO -->  'std::string' incrementally.
<!-- end header -->

<!-- begin header: stringset.h -->
  <!-- AUTO --><dt><a href="stringset.h">stringset.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  StringSet, a set of strings.
<!-- end header -->

<!-- begin header: smregexp.h -->
  <!-- AUTO --><dt><a href="smregexp.h">smregexp.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  Regular expression matching.
<!-- end header -->

</dl>


<h2>System Utilities</h2>

<p>
The following modules provide access to or wrappers around various
low-level system services.

<dl>

<!-- begin header: autofile.h -->
  <!-- AUTO --><dt><a href="autofile.h">autofile.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  AutoFILE, a simple wrapper around FILE* to open it or throw
  <!-- AUTO -->  an exception, and automatically close it.
<!-- end header -->

<!-- begin header: missing.h -->
  <!-- AUTO --><dt><a href="missing.h">missing.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  Implementations of a few C library functions that are not present
  <!-- AUTO -->  on all platforms.
<!-- end header -->

<!-- begin header: mypopen.h -->
  <!-- AUTO --><dt><a href="mypopen.h">mypopen.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  Open a process and yield pipes to its stdin/stdout/stderr.
<!-- end header -->

<!-- begin header: mysig.h -->
  <!-- AUTO --><dt><a href="mysig.h">mysig.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  Some signal-related utilities.
<!-- end header -->

<!-- begin header: syserr.h -->
  <!-- AUTO --><dt><a href="syserr.h">syserr.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  Portable encapsulation of system-dependent error facilities like
  <!-- AUTO -->  UNIX's errno and Win32's GetLastError().
<!-- end header -->

<!-- begin header: sm-unixutil.h -->
  <!-- AUTO --><dt><a href="sm-unixutil.h">sm-unixutil.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  Some utilities on top of unix functions: writeAll(), readString().
<!-- end header -->

</dl>


<p>
These are obsolete:

<ul>

<li><a href="cycles.h">cycles.h</a>
    <a href="cycles.c">cycles.c</a>:
Report total number of processor cycles since the machine was turned on.
Uses the RDTSC instruction on x86.  This hasn't been updated to work
with x86-64 and RDTSC is not very useful anyway.

</ul>


<h2>Portability</h2>

<p>
These modules help insulate client code from the details of the system
it is running on.

<ul>

<li><a href="nonport.h">nonport.h</a>,
    <a href="nonport.cc">nonport.cc</a>:
A library of utility functions whose implementation is system-specific.
Generally, I try to encapsulate all system depenencies as functions
defined in nonport.

<li><a href="sm-macros.h">sm-macros.h</a>:
A bunch of useful macros.

<li><a href="typ.h">typ.h</a>:
Some type definitions like <code>byte</code> and <code>bool</code>, plus a few
utility macros.  Not clearly distinguished from <a href="sm-macros.h">sm-macros.h</a>
in purpose.

</ul>


<h2>Allocation</h2>

<p>
These modules provide additional control over the allocator.

<ul>

<li><a href="objpool.h">objpool.h</a>:
ObjPool, a custom allocator for fixed-size objects with embedded
'next' links.

</ul>


<h2>Exceptions</h2>

<p>
These modules define or throw exceptions.

<ul>

<li><a href="exc.h">exc.h</a>,
    <a href="exc.cc">exc.cc</a>:
Various exception classes.  The intent is derive everything from xBase,
so a program can catch this one exception type in main() and be assured
no exception will propagate out of the program (or any other unit of
granularity you want).

<li><a href="xassert.h">xassert.h</a>:
xassert is an assert()-like macro that throws an exception when it
fails, instead of calling abort().

</ul>


<h2>Serialization</h2>

<p>
The "flatten" serialization scheme is intended to allow sets of objects
to read and write themselves to files.

<ul>

<li><a href="bflatten.h">bflatten.h</a>,
    <a href="bflatten.cc">bflatten.cc</a>:
Implementation of the Flatten interface (<a href="flatten.h">flatten.h</a>)
for reading/writing binary files.

<li><a href="flatten.h">flatten.h</a>,
    <a href="flatten.cc">flatten.cc</a>:
Generic interface for serializing in-memory data structures to files.
Similar to Java's Serializable, but independently conceived, and has
superior version control facilities.

</ul>


<h2>Compiler/Translator Support</h2>

<p>
smbase has a number of modules that are of use to programs that
read and/or write source code.

<ul>

<li><a href="hashline.h">hashline.h</a>,
    <a href="hashline.cc">hashline.cc</a>:
HashLineMap, a mechanism for keeping track of #line directives in C
source files.  Provides efficient queries with respect to a set of
such directives.

<li><a href="srcloc.h">srcloc.h</a>,
    <a href="srcloc.cc">srcloc.cc</a>:
This module maintains a one-word data type called SourceLoc.
SourceLoc is a location within some file, e.g. line/col or character
offset information.  SourceLoc also encodes <em>which</em> file it
refers to.  This type is very useful for language processors (like
compilers) because it efficiently encodes location formation.
Decoding this into human-readable form is slower than incrementally
updating it, but decoding is made somewhat efficient with some
appropriate index structures.

<li><a href="boxprint.h">boxprint.h</a>
    <a href="boxprint.cc">boxprint.cc</a>:
BoxPrint functions as an output stream (sort of like <code>cout</code>)
with operations to indicate structure within the emitted text, so that
it can break lines intelligently.  It's used as part of a source-code
pretty-printer.

<li><a href="warn.h">warn.h</a>,
    <a href="warn.cc">warn.cc</a>:
Intended to provide a general interface for user-level warnings; the
design never really worked well.

</ul>


<h2>Testing and Debugging</h2>

<ul>

<li><a href="breaker.h">breaker.h</a>
    <a href="breaker.cc">breaker.cc</a>:
Function for putting a breakpoint in, to get debugger control just
before an exception is thrown.

<li><a href="test.h">test.h</a>:
A few test-harness macros.

<li><a href="trace.h">trace.h</a>,
    <a href="trace.cc">trace.cc</a>:
Module for recording and querying a set of debug tracing flags.
It is documented in <a href="trace.html">trace.html</a>.

<li><a href="trdelete.h">trdelete.h</a>,
    <a href="trdelete.cc">trdelete.cc</a>:
An <code>operator delete</code> which overwrites the deallocated memory with
0xAA before deallocating it.

</ul>


<h2>Miscellaneous</h2>

<ul>

<li><a href="crc.h">crc.h</a>
    <a href="crc.cc">crc.cc</a>:
32-bit cyclic redundancy check.

<li><a href="gprintf.h">gprintf.h</a>,
    <a href="gprintf.c">gprintf.c</a>:
General printf; calls a function to emit each piece.

<li><a href="owner.h">owner.h</a>:
Owner, a pointer that deallocates its referrent in its destructor.
Similar to auto_ptr in the C++ Standard.

<li><a href="point.h">point.h</a>,
    <a href="point.cc">point.cc</a>:
Point, a pair of integers.

</ul>


<h2>Utility Scripts</h2>

<ul>

<li><a href="run-flex.pl">run-flex.pl</a>:
Perl script to run flex and massage its output for portability.

</ul>


</body>

</HTML>
