<!DOCTYPE html>
<HTML lang="en">

<HEAD>
  <TITLE>smbase</TITLE>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <style>
    H1 { font-size: 150% }
    H2 { font-size: 125% }
    H3 { font-size: 100% }
    P.title {
      font-size: 175%;
      text-align: center;
    }
    dl {
      padding-left: 1.5em;
    }
  </style>
</HEAD>

<body>

<p class="title"><b>smbase: A Utility Library</b></p>

<h1 id="intro">Introduction</h1>

<p>
"smbase" stands for Scott McPeak's Base Library (sorry, naming things
is not my specialty).  It's a bunch of
utility modules I use in virtually all of my projects.  The entire
library is in the public domain.

<p>
There is some overlap in functionality between smbase and the C++
Standard Library.  Partly this is because smbase predates the standard
library, and partly this is due to my disagreement with certain aspects
of the standard library design (although the relevance of those
disagreements has diminished with time).  My intent, going forward, is
to use standard library facilities when possible.

<p>
smbase has developed organically, in response to specific needs.
While each module individually has been reasonably carefully designed,
the library as a whole has not.  Consequently, the modules to not
always orthogonally cover a given design space, and some of the
modules are now considered obsolete (marked below as such).


<h1 id="toc">Table of contents</h1>

<!-- BEGIN CONTENTS -->
<!-- automatically generated by insert-html-toc; do not edit the TOC directly -->
<ul>
  <li><a class="toc" href="#build_instructions">Build Instructions</a>
  <li><a class="toc" href="#modules">Containers</a>
  <ul>
    <li><a class="toc" href="#linked_lists">Linked Lists</a>
    <li><a class="toc" href="#arrays">Arrays</a>
    <li><a class="toc" href="#arrays_of_bits">Arrays of Bits</a>
    <li><a class="toc" href="#maps">Hash Tables and Maps (obsolete)</a>
    <li><a class="toc" href="#maps_of_strings">Maps with Strings as Keys (obsolete)</a>
    <li><a class="toc" href="#std_container_utils">Standard container utilities</a>
    <li><a class="toc" href="#gdv">General data values</a>
  </ul>
  <li><a class="toc" href="#scalars">Scalars</a>
  <ul>
    <li><a class="toc" href="#strings">Strings</a>
    <li><a class="toc" href="#numbers">Numbers</a>
    <li><a class="toc" href="#comparison">Comparison</a>
  </ul>
  <li><a class="toc" href="#control_flow">Control flow</a>
  <ul>
    <li><a class="toc" href="#exceptions">Exceptions</a>
    <li><a class="toc" href="#leave_scope">Actions upon leaving a scope</a>
  </ul>
  <li><a class="toc" href="#memory_management">Memory management</a>
  <ul>
    <li><a class="toc" href="#owner_pointers">Owner pointers</a>
    <li><a class="toc" href="#reference_counting">Reference counting</a>
  </ul>
  <li><a class="toc" href="#interprocess">Interprocess communication</a>
  <ul>
    <li><a class="toc" href="#system_utilities">System Utilities</a>
    <li><a class="toc" href="#streams">Character streams</a>
    <li><a class="toc" href="#serialization">Serialization</a>
  </ul>
  <li><a class="toc" href="#application_domains">Application domains</a>
  <ul>
    <li><a class="toc" href="#language_processing">Programming language processing support</a>
    <li><a class="toc" href="#pretty_printing">Pretty printing</a>
    <li><a class="toc" href="#fonts">Fonts</a>
  </ul>
  <li><a class="toc" href="#uncategorized">Uncategorized</a>
  <ul>
    <li><a class="toc" href="#macros">Macros</a>
    <li><a class="toc" href="#portability">Portability</a>
    <li><a class="toc" href="#algorithms">Algorithms</a>
    <li><a class="toc" href="#testing">Testing and Debugging</a>
    <li><a class="toc" href="#header_wrappers">Header wrappers</a>
    <li><a class="toc" href="#misc">Miscellaneous</a>
  </ul>
  <li><a class="toc" href="#utility_scripts">Utility Scripts</a>
</ul>
<!-- END CONTENTS -->


<h1 id="build_instructions">Build Instructions</h1>

<p>
<pre>
  $ ./configure
  $ make
  $ make check
</pre>

<p>
<a href="configure"><code>./configure</code></a> does nothing, but exists
for consistency with other packages.

<p>
Configuration is done by creating an optional <code>config.mk</code>
file and, in that file, setting variables that are described at the top
of <a href="Makefile"><code>Makefile</code></a>.


<h1 id="modules">Containers</h1>

<p>
The following sections list all the smbase modules, grouped by
functionality.


<h2 id="linked_lists">Linked Lists</h2>

<p>
Linked lists are sequences of objects with O(1) insertion at the front
and iterators for traversal.  Most also have <em>mutators</em> for
traversing and modifying.

<p>
There are a couple of variants that support O(1) appending:

<dl>

<!-- begin header: vdtllist.h -->
  <!-- AUTO --><dt><a href="vdtllist.h">vdtllist.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  List of void*, with a pointer maintained to the last (tail)
  <!-- AUTO -->  element, for constant-time append.  Used by ASTList and VoidTailList.
<!-- end header -->

<!-- begin header: taillist.h -->
  <!-- AUTO --><dt><a href="taillist.h">taillist.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  List wrapper around VoidTailList, like ASTList, but it doesn't own
  <!-- AUTO -->  the elements.
<!-- end header -->

<!-- begin header: astlist.h -->
  <!-- AUTO --><dt><a href="astlist.h">astlist.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  ASTList, a list class for use in abstract syntax trees.
  <!-- AUTO -->  Owner list wrapper around VoidTailList.
  <!-- AUTO -->  The name 'AST' is because the first application is in ASTs.
<!-- end header -->

</dl>

<p>
The remainder of this section is obsolete, with
<code>std::list</code>, possibly in combination with
<code>std::unique_ptr</code>, replacing it.

<dl>

<!-- begin header: objlist.h -->
  <!-- AUTO --><dt><a href="objlist.h">objlist.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  Owner list of arbitrary dynamically-allocated objects.
  <!-- AUTO -->  NOTE: automatically generated from xobjlist.h -- do not edit directly
<!-- end header -->

<!-- begin header: sobjlist.h -->
  <!-- AUTO --><dt><a href="sobjlist.h">sobjlist.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  Serf (non-owning) list of arbitrary objects.
  <!-- AUTO -->  NOTE: automatically generated from xobjlist.h -- do not edit directly
<!-- end header -->

<!-- begin header: xobjlist.h -->
  <!-- AUTO --><dt><a href="xobjlist.h">xobjlist.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  Template file to be processed with m4 to generate one
  <!-- AUTO -->  of the wrappers around VoidList.
<!-- end header -->

<!-- begin header: voidlist.h -->
  <!-- AUTO --><dt><a href="voidlist.h">voidlist.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  List of void*.  This is used by ObjList and SObjList.
<!-- end header -->

<!-- begin header: objstack.h -->
  <!-- AUTO --><dt><a href="objstack.h">objstack.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  ObjStack, a stack of owned objects.  Built with a linked list.
<!-- end header -->

<!-- begin header: sobjstack.h -->
  <!-- AUTO --><dt><a href="sobjstack.h">sobjstack.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  SObjStack, a stack of non-owned objects.  Built with a linked list.
<!-- end header -->

</dl>


<h2 id="arrays">Arrays</h2>

<p>
Arrays are sequences of objects with O(1) random access and replacement.

<dl>

<!-- begin header: array2d.h -->
  <!-- AUTO --><dt><a href="array2d.h">array2d.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  Non-resizable 2D array with bounds checking.
  <!-- AUTO -->  Meeded because new T[i][j] is not legal if 'i' is not a constant.
<!-- end header -->

</dl>

<p>
Everything else in this section is obsoleted by <code>std::vector</code>.

<dl>

<!-- begin header: array.h -->
  <!-- AUTO --><dt><a href="array.h">array.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  Several array-like template classes, including growable arrays.
<!-- end header -->

<!-- begin header: bitwise_array.h -->
  <!-- AUTO --><dt><a href="bitwise_array.h">bitwise_array.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  Some array classes that use bitwise copying when expanding.
<!-- end header -->

<!-- begin header: arrayqueue.h -->
  <!-- AUTO --><dt><a href="arrayqueue.h">arrayqueue.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  ArrayQueue, a template class implementing a queue with an array.
  <!-- AUTO -->  Supports O(1) enqueue and dequeue.
<!-- end header -->

<!-- begin header: datablok.h -->
  <!-- AUTO --><dt><a href="datablok.h">datablok.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  DataBlock, an array of characters of a given length.  Useful when the
  <!-- AUTO -->  data may contain NUL ('\0') bytes.
<!-- end header -->

<!-- begin header: growbuf.h -->
  <!-- AUTO --><dt><a href="growbuf.h">growbuf.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  Extension of DataBlock that provides an append() function.
<!-- end header -->

<!-- begin header: arraymap.h -->
  <!-- AUTO --><dt><a href="arraymap.h">arraymap.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  ArrayMap, a map from integers to owner object pointers. Obsolete.
<!-- end header -->


</dl>


<h2 id="arrays_of_bits">Arrays of Bits</h2>

<p>
Arrays of bits are handled specially, because they are implemented by
storing multiple bits per byte.

<dl>

<!-- begin header: bit2d.h -->
  <!-- AUTO --><dt><a href="bit2d.h">bit2d.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  Two-dimensional array of bits.
<!-- end header -->

<!-- begin header: bitarray.h -->
  <!-- AUTO --><dt><a href="bitarray.h">bitarray.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  One-dimensional array of bits.
<!-- end header -->

</dl>


<h2 id="maps">Hash Tables and Maps (obsolete)</h2>

<p>
Maps support mapping from arbitrary domains to arbitrary ranges.  Mappings
can be added and queried in amortized O(1) time, but the constant factor
is considerably higher than for arrays and lists.

<p>
Everything in this section is obsoleted by <code>std::map</code>,
possibly in combination with <code>std::unique_ptr</code>, and perhaps
<code>std::unordered_map</code> in some cases.

<p>
Probably the most common map is the PtrMap template, which will map
from pointers to pointers, for arbitrary pointed-to types.

<dl>

<!-- begin header: ptrmap.h -->
  <!-- AUTO --><dt><a href="ptrmap.h">ptrmap.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  PtrMap, a non-owning template class built on top of VoidPtrMap.
<!-- end header -->

<!-- begin header: objmap.h -->
  <!-- AUTO --><dt><a href="objmap.h">objmap.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  ObjMap, a PtrMap where the values (but not keys) are owned.
<!-- end header -->

<!-- begin header: oobjmap.h -->
  <!-- AUTO --><dt><a href="oobjmap.h">oobjmap.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  Owner object map, implemented with a hash table
  <!-- AUTO -->  maps pointer-to-key-object to pointer-to-value-object, and owns
  <!-- AUTO -->  all instances of value-object (they are deallocated when the
  <!-- AUTO -->  map itself goes away).
<!-- end header -->

<!-- begin header: ptrintmap.h -->
  <!-- AUTO --><dt><a href="ptrintmap.h">ptrintmap.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  Map from KEY* to int for arbitrary type KEY
  <!-- AUTO -->  (key is not owned by the table).
<!-- end header -->

<!-- begin header: vptrmap.h -->
  <!-- AUTO --><dt><a href="vptrmap.h">vptrmap.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  Hashtable-based map from void* to void*.
  <!-- AUTO -->  Used by ptrmap.h and objmap.h.
<!-- end header -->

</dl>

<p>
If the key can always be derived from the data (for example, the key
is stored in the data object), then it is inefficient to store both in
the table.  The following variants require a function pointer to map
from data to keys.

<dl>

<!-- begin header: hashtbl.h -->
  <!-- AUTO --><dt><a href="hashtbl.h">hashtbl.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  Hash table mapping arbitrary keys to void*, where
  <!-- AUTO -->  the stored pointers can be used to derive the key,
  <!-- AUTO -->  and cannot be NULL.
<!-- end header -->

<!-- begin header: thashtbl.h -->
  <!-- AUTO --><dt><a href="thashtbl.h">thashtbl.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  Template class built on top of HashTable.  Maps KEY* to VALUE*.
<!-- end header -->

<!-- begin header: ohashtbl.h -->
  <!-- AUTO --><dt><a href="ohashtbl.h">ohashtbl.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  OwnerHashTable, a hash table that owns the values.  Maps void* to T*.
<!-- end header -->

</dl>

<p>
The above can be used to efficiently implement a set of T*.

<dl>

<!-- begin header: sobjset.h -->
  <!-- AUTO --><dt><a href="sobjset.h">sobjset.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  SObjSet, a non-owning set of objects implemented on top of HashTable.
<!-- end header -->

</dl>

<p>
There are two specialized versions that combine O(1) insertion
and query of a hash table with O(1) enqueue and dequeue of an
array.

<dl>

<!-- begin header: okhasharr.h -->
  <!-- AUTO --><dt><a href="okhasharr.h">okhasharr.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  OwnerKHashArray, a combination of an owner hash table and an array/stack.
<!-- end header -->

<!-- begin header: okhashtbl.h -->
  <!-- AUTO --><dt><a href="okhashtbl.h">okhashtbl.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  OwnerKHashTable, a version of okhasharr.h with type-safe keys ("k" for keys).
<!-- end header -->

</dl>


<h2 id="maps_of_strings">Maps with Strings as Keys (obsolete)</h2>

<p>
Mapping from strings is a nontrivial extension of the above maps
because comparison is more than a pointer equality test.  So there
are some specialized maps from strings.

<p>
Everything in this section is obsolete, as it can be done using standard
library maps and an appropriate comparator.

<p>
If you have a function that can map from data to (string) key,
then StringHash and TStringHash (the template version) are the
most efficient:

<dl>

<!-- begin header: strhash.h -->
  <!-- AUTO --><dt><a href="strhash.h">strhash.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  Hash table mapping strings to arbitrary pointers, where
  <!-- AUTO -->  the stored pointers can be used to derive the key, and
  <!-- AUTO -->  cannot be NULL.
<!-- end header -->

</dl>

<p>
The StringVoidDict and templates wrapped around it are more general.
They do not require a function to map from data to key, support
query-then-modify-result, and alphabetic iteration.

<dl>

<!-- begin header: strobjdict.h -->
  <!-- AUTO --><dt><a href="strobjdict.h">strobjdict.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  StringObjDict, a case-sensitive map from strings to object pointers.
  <!-- AUTO -->  The dictionary owns the referred-to objects.
<!-- end header -->

<!-- begin header: strsobjdict.h -->
  <!-- AUTO --><dt><a href="strsobjdict.h">strsobjdict.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  StringSObjDict, a case-sensitive map from strings to object pointers.
  <!-- AUTO -->  The dictionary does *not* own the referred-to objects.
<!-- end header -->

<!-- begin header: strintdict.h -->
  <!-- AUTO --><dt><a href="strintdict.h">strintdict.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  Dictionary of intptr_t (integers that fit into void*), indexed by string
  <!-- AUTO -->  (case-sensitive).
<!-- end header -->

<!-- begin header: xstrobjdict.h -->
  <!-- AUTO --><dt><a href="xstrobjdict.h">xstrobjdict.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  Template file to be processed with m4 to generate one
  <!-- AUTO -->  of the wrappers around StringVoidDict.
<!-- end header -->

<!-- begin header: svdict.h -->
  <!-- AUTO --><dt><a href="svdict.h">svdict.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  StringVoidDict, a case-sensitive map from strings to void* pointers.
  <!-- AUTO -->  Built on top of StringHash.
<!-- end header -->

</dl>

<p>
Finally, there is a module to map from strings to strings.

<dl>

<!-- begin header: strdict.h -->
  <!-- AUTO --><dt><a href="strdict.h">strdict.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  StringDict, a case-sensitive map from strings to strings.
  <!-- AUTO -->  Currently, this is implemented with a linked list and consequently
  <!-- AUTO -->  not efficient.  But it will work when efficiency does not matter,
  <!-- AUTO -->  and could be reimplemented (preserving the interface) with something
  <!-- AUTO -->  better.
<!-- end header -->

</dl>


<h2 id="std_container_utils">Standard container utilities</h2>

<dl>

<!-- begin header: container-utils.h -->
  <!-- AUTO --><dt><a href="container-utils.h">container-utils.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  Utilities for C++ containers.
<!-- end header -->

<!-- begin header: map-utils.h -->
  <!-- AUTO --><dt><a href="map-utils.h">map-utils.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  Utilities related to std::map.
<!-- end header -->

<!-- begin header: set-utils.h -->
  <!-- AUTO --><dt><a href="set-utils.h">set-utils.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  Utilities related to std::set.
<!-- end header -->

<!-- begin header: vector-utils.h -->
  <!-- AUTO --><dt><a href="vector-utils.h">vector-utils.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  Utilities for std::vector.
<!-- end header -->

</dl>


<h2 id="gdv">General data values</h2>

<dl>

<!-- begin header: gdvalue.h -->
  <!-- AUTO --><dt><a href="gdvalue.h">gdvalue.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  General Data Value: integer, sequence, map, etc.
<!-- end header -->

<!-- begin header: gdvsymbol.h -->
  <!-- AUTO --><dt><a href="gdvsymbol.h">gdvsymbol.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  GDVSymbol class.
<!-- end header -->

<!-- begin header: gdvalue-write-options.h -->
  <!-- AUTO --><dt><a href="gdvalue-write-options.h">gdvalue-write-options.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  GDValueWriteOptions class.
<!-- end header -->

<!-- begin header: gdvalue-writer.h -->
  <!-- AUTO --><dt><a href="gdvalue-writer.h">gdvalue-writer.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  GDValueWriter class.
<!-- end header -->

<!-- begin header: gdvalue-reader.h -->
  <!-- AUTO --><dt><a href="gdvalue-reader.h">gdvalue-reader.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  GDValueReader class, which does text deserialization for GDValue.
<!-- end header -->

<!-- begin header: gdvalue-reader-exception.h -->
  <!-- AUTO --><dt><a href="gdvalue-reader-exception.h">gdvalue-reader-exception.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  GDValueReaderException class, used to report GDValue syntax errors.
<!-- end header -->

</dl>

<p>
This isn't part of GDV, but is a conceptual precursor:

<dl>

<!-- begin header: functional-set.h -->
  <!-- AUTO --><dt><a href="functional-set.h">functional-set.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  FunctionalSet, FSElement, and FunctionalSetManager.
<!-- end header -->

</dl>


<h1 id="scalars">Scalars</h1>

<h2 id="strings">Strings</h2>

<p>
Strings are sequences of characters, although in terms of library
categorization, they are regarded as scalars since the most common
operations treat them as a unit.

<dl>

<!-- begin header: codepoint.h -->
  <!-- AUTO --><dt><a href="codepoint.h">codepoint.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  Routines related to Unicode code points: tests, conversions, etc.
<!-- end header -->

<!-- begin header: string-utils.h -->
  <!-- AUTO --><dt><a href="string-utils.h">string-utils.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  Utilities related to std::string.
<!-- end header -->

<!-- begin header: strutil.h -->
  <!-- AUTO --><dt><a href="strutil.h">strutil.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  A set of generic string utilities, including replace(), translate(),
  <!-- AUTO -->  trimWhitespace(), encodeWithEscapes(), etc.
  <!-- AUTO --><br><br>
  <!-- AUTO -->  TODO: This module should be combined with string-utils.h.
<!-- end header -->

<!-- begin header: stringb.h -->
  <!-- AUTO --><dt><a href="stringb.h">stringb.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  Define the 'stringb' macro that allows in-place string construction
  <!-- AUTO -->  using 'operator&lt;&lt;'.
<!-- end header -->

<!-- begin header: stringf.h -->
  <!-- AUTO --><dt><a href="stringf.h">stringf.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  Printf-like construction of std::string.
<!-- end header -->

<!-- begin header: strcmp-compare.h -->
  <!-- AUTO --><dt><a href="strcmp-compare.h">strcmp-compare.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  Comparison functions based on strcmp.
<!-- end header -->

<!-- begin header: strtable.h -->
  <!-- AUTO --><dt><a href="strtable.h">strtable.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  Implements a collection of immutable strings with unique representatives.
<!-- end header -->

<!-- begin header: gprintf.h -->
  <!-- AUTO --><dt><a href="gprintf.h">gprintf.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  Generalized printf interface.
  <!-- AUTO -->  See http://www.efgh.com/software/gprintf.htm.
  <!-- AUTO -->  This file is in the public domain.
<!-- end header -->

<!-- begin header: strtokp.h -->
  <!-- AUTO --><dt><a href="strtokp.h">strtokp.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  StrtokParse, a class that parses a string similar to how strtok()
  <!-- AUTO -->  works, but provides a more convenient (and thread-safe) interface.
  <!-- AUTO -->  Similar to Java's StringTokenizer.
<!-- end header -->

<!-- begin header: strtokpc.h -->
  <!-- AUTO --><dt><a href="strtokpc.h">strtokpc.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  String tokenizing class.  Modifies an input string in-place to
  <!-- AUTO -->  null-terminate individual tokens, and undoes modifications on
  <!-- AUTO -->  destruction.
<!-- end header -->

<!-- begin header: parsestring.h -->
  <!-- AUTO --><dt><a href="parsestring.h">parsestring.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  ParseString class.
<!-- end header -->

</dl>

All of these are obsolete:

<dl>

<!-- begin header: str.h -->
  <!-- AUTO --><dt><a href="str.h">str.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  2024-05-20: This is a compatibility header.  It declares 'string' as
  <!-- AUTO -->  an alias for 'std::string', and has some other stuff related to
  <!-- AUTO -->  legacy usage.  New code should avoid it.
<!-- end header -->

<!-- begin header: stringset.h -->
  <!-- AUTO --><dt><a href="stringset.h">stringset.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  StringSet, a set of strings.
<!-- end header -->

<!-- begin header: smregexp.h -->
  <!-- AUTO --><dt><a href="smregexp.h">smregexp.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  Regular expression matching.
<!-- end header -->

</dl>


<h2 id="numbers">Numbers</h2>

<dl>

<!-- begin header: sm-ap-int.h -->
  <!-- AUTO --><dt><a href="sm-ap-int.h">sm-ap-int.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  <code>APInteger</code>, an arbitrary-precision integer class.
<!-- end header -->

<!-- begin header: sm-ap-uint.h -->
  <!-- AUTO --><dt><a href="sm-ap-uint.h">sm-ap-uint.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  <code>APUInteger</code>, an arbitrary-precision unsigned integer class.
  <!-- AUTO --><br><br>
  <!-- AUTO -->  This is primarily meant to be used as part of the implementation of
  <!-- AUTO -->  <code>APInteger</code> defined in <code>sm-ap-int.h</code>.
<!-- end header -->

<!-- begin header: overflow.h -->
  <!-- AUTO --><dt><a href="overflow.h">overflow.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  Arithmetic that throws <code>XOverflow</code> on overflow.
<!-- end header -->

<!-- begin header: xoverflow.h -->
  <!-- AUTO --><dt><a href="xoverflow.h">xoverflow.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  <code>XOverflow</code> exception class.
<!-- end header -->

<!-- begin header: div-up.h -->
  <!-- AUTO --><dt><a href="div-up.h">div-up.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  div_up function template.
<!-- end header -->

<!-- begin header: d2vector.h -->
  <!-- AUTO --><dt><a href="d2vector.h">d2vector.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  Simple 2d points, lines, and vectors using doubles.
<!-- end header -->

<!-- begin header: rectangle.h -->
  <!-- AUTO --><dt><a href="rectangle.h">rectangle.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  TRectangle class.
<!-- end header -->

<!-- begin header: point.h -->
  <!-- AUTO --><dt><a href="point.h">point.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  Point, a pair of numbers.
<!-- end header -->

<!-- begin header: datetime.h -->
  <!-- AUTO --><dt><a href="datetime.h">datetime.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  Some date/time routines.
<!-- end header -->

</dl>


<h2 id="comparison">Comparison</h2>

<dl>

<!-- begin header: compare-util.h -->
  <!-- AUTO --><dt><a href="compare-util.h">compare-util.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  Utilities for implementing three-way compare.
<!-- end header -->

<!-- begin header: sm-compare.h -->
  <!-- AUTO --><dt><a href="sm-compare.h">sm-compare.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  StrongOrdering enum, similar to standard <code>&lt;compare&gt;</code>, but without
  <!-- AUTO -->  requiring C++20.
  <!-- AUTO --><br><br>
  <!-- AUTO -->  This is the same idea as <code>compare-util.h</code>, except with an enum class
  <!-- AUTO -->  as the result instead of <code>int</code>.  I'm not sure which I want to commit
  <!-- AUTO -->  to, but at the moment I'm leaning toward plain <code>int</code>.
<!-- end header -->

<!-- begin header: strictly-sorted.h -->
  <!-- AUTO --><dt><a href="strictly-sorted.h">strictly-sorted.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  is_strictly_sorted function.
<!-- end header -->

</dl>


<h1 id="control_flow">Control flow</h1>

<h2 id="exceptions">Exceptions</h2>

<p>
These modules define or throw exceptions.

<dl>

<!-- begin header: exc.h -->
  <!-- AUTO --><dt><a href="exc.h">exc.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  Various exception classes.  The intent is derive everything from
  <!-- AUTO -->  XBase, so a program can catch this one exception type in main() and
  <!-- AUTO -->  be assured no exception will propagate out of the program (or any
  <!-- AUTO -->  other unit of granularity you want).
<!-- end header -->

<!-- begin header: xassert.h -->
  <!-- AUTO --><dt><a href="xassert.h">xassert.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  xassert is an assert()-like macro that throws an exception when it
  <!-- AUTO -->  fails, instead of calling abort().
<!-- end header -->

</dl>


<h2 id="leave_scope">Actions upon leaving a scope</h2>

<dl>

<!-- begin header: on-leaving-scope.h -->
  <!-- AUTO --><dt><a href="on-leaving-scope.h">on-leaving-scope.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  Perform some cleanup action when leaving a scope.
<!-- end header -->

<!-- begin header: save-restore.h -->
  <!-- AUTO --><dt><a href="save-restore.h">save-restore.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  Facility for saving a value and restoring it upon return.
<!-- end header -->

<!-- begin header: vector-push-pop.h -->
  <!-- AUTO --><dt><a href="vector-push-pop.h">vector-push-pop.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  <code>VECTOR_PUSH_POP</code> macro to push a value and pop it on scope exit.
<!-- end header -->

</dl>


<h1 id="memory_management">Memory management</h1>

<h2 id="owner_pointers">Owner pointers</h2>

<dl>

<!-- begin header: owner.h -->
  <!-- AUTO --><dt><a href="owner.h">owner.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  Owner, a pointer that deallocates its referrent in its destructor.
  <!-- AUTO -->  Similar to unique_ptr in the C++ Standard.
<!-- end header -->

<!-- begin header: objpool.h -->
  <!-- AUTO --><dt><a href="objpool.h">objpool.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  ObjPool, a custom allocator for fixed-size objects with embedded
  <!-- AUTO -->  'next' links.  This is for objects meant to be re-used frequently,
  <!-- AUTO -->  with high locality
<!-- end header -->

</dl>


<h2 id="reference_counting">Reference counting</h2>

<dl>

<!-- begin header: refct-serf.h -->
  <!-- AUTO --><dt><a href="refct-serf.h">refct-serf.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  Reference-counted serf pointer.
<!-- end header -->

<!-- begin header: rcserflist.h -->
  <!-- AUTO --><dt><a href="rcserflist.h">rcserflist.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  Array-backed sequence of reference-counted pointers.
<!-- end header -->

<!-- begin header: sm-rc-ptr.h -->
  <!-- AUTO --><dt><a href="sm-rc-ptr.h">sm-rc-ptr.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  RCPtr template class.
<!-- end header -->

<!-- begin header: sm-rc-obj.h -->
  <!-- AUTO --><dt><a href="sm-rc-obj.h">sm-rc-obj.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  RefCountObject class.
<!-- end header -->

<!-- begin header: objcount.h -->
  <!-- AUTO --><dt><a href="objcount.h">objcount.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  Things related to "object count" idiom.
<!-- end header -->

</dl>


<h1 id="interprocess">Interprocess communication</h1>

<h2 id="system_utilities">System Utilities</h2>

<p>
The following modules provide access to or wrappers around various
low-level system services.

<dl>

<!-- begin header: sm-file-util.h -->
  <!-- AUTO --><dt><a href="sm-file-util.h">sm-file-util.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  smbase file utilities.
<!-- end header -->

<!-- begin header: autofile.h -->
  <!-- AUTO --><dt><a href="autofile.h">autofile.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  AutoFILE, a simple wrapper around FILE* to open it or throw
  <!-- AUTO -->  an exception, and automatically close it.
<!-- end header -->

<!-- begin header: binary-stdin.h -->
  <!-- AUTO --><dt><a href="binary-stdin.h">binary-stdin.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  Set stdin and/or stdout to binary mode.
<!-- end header -->

<!-- begin header: missing.h -->
  <!-- AUTO --><dt><a href="missing.h">missing.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  Implementations of a few C library functions that are not present
  <!-- AUTO -->  on all platforms.
<!-- end header -->

<!-- begin header: mypopen.h -->
  <!-- AUTO --><dt><a href="mypopen.h">mypopen.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  Open a process and yield pipes to its stdin/stdout/stderr.
<!-- end header -->

<!-- begin header: mysig.h -->
  <!-- AUTO --><dt><a href="mysig.h">mysig.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  Some signal-related utilities.
<!-- end header -->

<!-- begin header: syserr.h -->
  <!-- AUTO --><dt><a href="syserr.h">syserr.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  Portable encapsulation of system-dependent error facilities like
  <!-- AUTO -->  UNIX's errno and Win32's GetLastError().
<!-- end header -->

<!-- begin header: sm-unixutil.h -->
  <!-- AUTO --><dt><a href="sm-unixutil.h">sm-unixutil.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  Some utilities on top of unix functions: writeAll(), readString().
<!-- end header -->

<!-- begin header: sm-posix.h -->
  <!-- AUTO --><dt><a href="sm-posix.h">sm-posix.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  Wrapper around some POSIX headers.
<!-- end header -->

<!-- begin header: run-process.h -->
  <!-- AUTO --><dt><a href="run-process.h">run-process.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  Run a process.
<!-- end header -->

</dl>

<p>
This is obsolete:

<dl>

<!-- begin header: cycles.h -->
  <!-- AUTO --><dt><a href="cycles.h">cycles.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  Report total number of processor cycles since the machine was turned
  <!-- AUTO -->  on.  Uses the RDTSC instruction on x86.  This hasn't been updated to
  <!-- AUTO -->  work with x86-64 and RDTSC is not very useful anyway.
<!-- end header -->

</dl>


<h2 id="streams">Character streams</h2>

<dl>

<!-- begin header: counting-ostream.h -->
  <!-- AUTO --><dt><a href="counting-ostream.h">counting-ostream.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  ostream that just counts the characters written to it.
<!-- end header -->

<!-- begin header: ofstreamts.h -->
  <!-- AUTO --><dt><a href="ofstreamts.h">ofstreamts.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  An ofstream which is timestamp-conscious.  It first writes to a
  <!-- AUTO -->  temporary file, and on success renames it to the target destination.
<!-- end header -->

</dl>


<h2 id="serialization">Serialization</h2>

<p>
The "flatten" serialization scheme is intended to allow sets of objects
to read and write themselves to files.

<dl>

<!-- begin header: flatten.h -->
  <!-- AUTO --><dt><a href="flatten.h">flatten.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  Generic interface for serializing in-memory data structures to files.
  <!-- AUTO -->  Similar to Java's Serializable, but independently conceived, and has
  <!-- AUTO -->  superior version control facilities.
<!-- end header -->

<!-- begin header: bflatten.h -->
  <!-- AUTO --><dt><a href="bflatten.h">bflatten.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  Implementation of the Flatten interface for reading/writing binary files.
<!-- end header -->

<!-- begin header: flatutil.h -->
  <!-- AUTO --><dt><a href="flatutil.h">flatutil.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  additional utilities layered upon 'flatten' interface
<!-- end header -->

</dl>


<h1 id="application_domains">Application domains</h1>

<h2 id="language_processing">Programming language processing support</h2>

<p>
smbase has a number of modules that are of use to programs that
process programming languages.

<dl>

<!-- begin header: hashline.h -->
  <!-- AUTO --><dt><a href="hashline.h">hashline.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  HashLineMap, a mechanism for keeping track of #line directives in C
  <!-- AUTO -->  source files.  Provides efficient queries with respect to a set of
  <!-- AUTO -->  such directives.
<!-- end header -->

<!-- begin header: srcloc.h -->
  <!-- AUTO --><dt><a href="srcloc.h">srcloc.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  This module maintains a one-word data type called SourceLoc.
  <!-- AUTO -->  SourceLoc is a location within some file, e.g. line/col or character
  <!-- AUTO -->  offset information.  SourceLoc also encodes *which* file it
  <!-- AUTO -->  refers to.  This type is very useful for language processors (like
  <!-- AUTO -->  compilers) because it efficiently encodes location formation.
  <!-- AUTO -->  Decoding this into human-readable form is slower than incrementally
  <!-- AUTO -->  updating it, but decoding is made somewhat efficient with some
  <!-- AUTO -->  appropriate index structures.
<!-- end header -->

<!-- begin header: file-line-col.h -->
  <!-- AUTO --><dt><a href="file-line-col.h">file-line-col.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  FileLineCol, a data triple.
  <!-- AUTO --><br><br>
  <!-- AUTO -->  Whereas srcloc.h is concerned with a compact representation, this
  <!-- AUTO -->  class's main goal is ease of use.
<!-- end header -->

<!-- begin header: gcc-options.h -->
  <!-- AUTO --><dt><a href="gcc-options.h">gcc-options.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  GCCOptions class.
<!-- end header -->

</dl>


<h2 id="pretty_printing">Pretty printing</h2>

<p>
Pretty printing is surprisingly difficult.  Perhaps that explains why I
have three different modules to do it?

<dl>

<!-- begin header: boxprint.h -->
  <!-- AUTO --><dt><a href="boxprint.h">boxprint.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  BoxPrint functions as an output stream (sort of like cout) with
  <!-- AUTO -->  operations to indicate structure within the emitted text, so that it
  <!-- AUTO -->  can break lines intelligently.  It's used as part of a source-code
  <!-- AUTO -->  pretty-printer.
<!-- end header -->

<!-- begin header: pprint.h -->
  <!-- AUTO --><dt><a href="pprint.h">pprint.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  pretty-print code while emitting it
<!-- end header -->

<!-- begin header: tree-print.h -->
  <!-- AUTO --><dt><a href="tree-print.h">tree-print.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  TreePrint class, which holds a tree to print while it is being built.
  <!-- AUTO -->  It then prints that tree to an ostream in the 'print()' method.
<!-- end header -->

</dl>


<h2 id="utf8">UTF-8</h2>

<p>
These modules provide basic UTF-8 encoding and decoding.

<dl>

<!-- begin header: utf8-reader.h -->
  <!-- AUTO --><dt><a href="utf8-reader.h">utf8-reader.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  Decode UTF-8.
<!-- end header -->

<!-- begin header: utf8-writer.h -->
  <!-- AUTO --><dt><a href="utf8-writer.h">utf8-writer.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  Encode UTF-8.
<!-- end header -->


</dl>


<h2 id="fonts">Fonts</h2>

<dl>

<!-- begin header: bdffont.h -->
  <!-- AUTO --><dt><a href="bdffont.h">bdffont.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  Parse and represent BDF fonts in memory.
<!-- end header -->

</dl>


<h1 id="uncategorized">Uncategorized</h1>

<h2 id="macros">Macros</h2>

<dl>

<!-- begin header: sm-pp-util.h -->
  <!-- AUTO --><dt><a href="sm-pp-util.h">sm-pp-util.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  Preprocessor utilities.
<!-- end header -->

<!-- begin header: sm-macros.h -->
  <!-- AUTO --><dt><a href="sm-macros.h">sm-macros.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  A bunch of useful macros.
<!-- end header -->

<!-- begin header: sm-override.h -->
  <!-- AUTO --><dt><a href="sm-override.h">sm-override.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  Define OVERRIDE macro.
<!-- end header -->

<!-- begin header: sm-noexcept.h -->
  <!-- AUTO --><dt><a href="sm-noexcept.h">sm-noexcept.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  Define NOEXCEPT macro.
<!-- end header -->

</dl>


<h2 id="portability">Portability</h2>

<p>
These modules help insulate client code from the details of the system
it is running on.

<dl>

<!-- begin header: sm-platform.h -->
  <!-- AUTO --><dt><a href="sm-platform.h">sm-platform.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  Platform detection.
<!-- end header -->

<!-- begin header: nonport.h -->
  <!-- AUTO --><dt><a href="nonport.h">nonport.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  A library of utility functions whose implementation is
  <!-- AUTO -->  system-specific.  Generally, I try to encapsulate all system
  <!-- AUTO -->  depenencies as functions defined in nonport.
<!-- end header -->

<!-- begin header: typ.h -->
  <!-- AUTO --><dt><a href="typ.h">typ.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  Old file that can no longer be used because it has #error.
<!-- end header -->

<!-- begin header: pointer-utils.h -->
  <!-- AUTO --><dt><a href="pointer-utils.h">pointer-utils.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  Miscellaneous utilities related to pointer manipulation.
<!-- end header -->

<!-- begin header: double-width-type.h -->
  <!-- AUTO --><dt><a href="double-width-type.h">double-width-type.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  <code>DoubleWidthType</code> template meta-lookup.
<!-- end header -->

</dl>


<h2 id="algorithms">Algorithms</h2>

<dl>

<!-- begin header: binary-lookup.h -->
  <!-- AUTO --><dt><a href="binary-lookup.h">binary-lookup.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  binary_lookup function.
<!-- end header -->

<!-- begin header: sm-swap.h -->
  <!-- AUTO --><dt><a href="sm-swap.h">sm-swap.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  Define 'swap' template.
<!-- end header -->

<!-- begin header: sm-random.h -->
  <!-- AUTO --><dt><a href="sm-random.h">sm-random.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  Utilities related to random number generation.
<!-- end header -->

</dl>


<h2 id="testing">Testing and Debugging</h2>

<dl>

<!-- begin header: breaker.h -->
  <!-- AUTO --><dt><a href="breaker.h">breaker.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  Function for putting a breakpoint in, to get debugger control just
  <!-- AUTO -->  before an exception is thrown.
<!-- end header -->

<!-- begin header: sm-test.h -->
  <!-- AUTO --><dt><a href="sm-test.h">sm-test.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  A few test-harness macros.
<!-- end header -->

<!-- begin header: dummy-printf.h -->
  <!-- AUTO --><dt><a href="dummy-printf.h">dummy-printf.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  Declare <code>dummy_printf</code>, a printf-like function that does nothing.
  <!-- AUTO --><br><br>
  <!-- AUTO -->  Normally, clients <code>#include "sm-test.h"</code> to get this, but that file
  <!-- AUTO -->  requires C++, so this is an alternative for C clients.
<!-- end header -->

<!-- begin header: trace.h -->
  <!-- AUTO --><dt><a href="trace.h">trace.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  Module for recording and querying a set of debug tracing flags.
  <!-- AUTO -->  It is documented in trace.html.
<!-- end header -->

See <a href="trace.html">trace.html</a>.

<!-- begin header: dev-warning.h -->
  <!-- AUTO --><dt><a href="dev-warning.h">dev-warning.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  "Developer warning" mechanism.
<!-- end header -->

<!-- begin header: warn.h -->
  <!-- AUTO --><dt><a href="warn.h">warn.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  Intended to provide a general interface for user-level warnings; the
  <!-- AUTO -->  design never really worked well.
<!-- end header -->

<!-- begin header: trdelete.h -->
  <!-- AUTO --><dt><a href="trdelete.h">trdelete.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  An 'operator delete' which overwrites the deallocated memory with
  <!-- AUTO -->  0xAA before deallocating it.
<!-- end header -->

</dl>


<h2 id="header_wrappers">Header wrappers</h2>

<p>
These wrap some third-party headers.

<dl>

<!-- begin header: sm-windows.h -->
  <!-- AUTO --><dt><a href="sm-windows.h">sm-windows.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  Wrapper around windows.h.
<!-- end header -->

<!-- begin header: sm_strstream.h -->
  <!-- AUTO --><dt><a href="sm_strstream.h">sm_strstream.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  portable header for c++ strstream
<!-- end header -->

<!-- begin header: sm-ostream.h -->
  <!-- AUTO --><dt><a href="sm-ostream.h">sm-ostream.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  similar to old ostream.h
<!-- end header -->

<!-- begin header: sm-stdint.h -->
  <!-- AUTO --><dt><a href="sm-stdint.h">sm-stdint.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  wrapper around stdint.h
<!-- end header -->

<!-- begin header: sm-fstream.h -->
  <!-- AUTO --><dt><a href="sm-fstream.h">sm-fstream.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  similar to old fstream.h
<!-- end header -->

<!-- begin header: sm-iostream.h -->
  <!-- AUTO --><dt><a href="sm-iostream.h">sm-iostream.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  similar to old iostream.h
<!-- end header -->

<!-- begin header: sm-new.h -->
  <!-- AUTO --><dt><a href="sm-new.h">sm-new.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  like old new.h
<!-- end header -->

</dl>


<h2 id="misc">Miscellaneous</h2>

<dl>

<!-- begin header: crc.h -->
  <!-- AUTO --><dt><a href="crc.h">crc.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  32-bit cyclic redundancy check.
<!-- end header -->

<!-- begin header: pair.h -->
  <!-- AUTO --><dt><a href="pair.h">pair.h</a>
  <!-- AUTO --><dd>
  <!-- AUTO -->  approximately standard-conforming (20.2.2) definition of pair&lt;&gt;
<!-- end header -->

</dl>


<h1 id="utility_scripts">Utility Scripts</h1>

<dl>

<dt><a href="run-flex.pl">run-flex.pl</a>
<dd>Perl script to run flex and massage its output for portability.

</dl>


</body>

</HTML>
