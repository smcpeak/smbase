gdvalue-design.txt
==================


Goals
=====

* Have a C++ class, 'GDValue', that can store a variety of useful data
  types as a discriminated union:
  - Absent value
  - Boolean
  - Number
    - Arbitrary-precision integer
    - Floating-point number?
  - String-like
    - Symbol: strings that represent names of things or concepts
    - String: sequence of Unicode code points
    - Octet array
  - Container
    - Tuple?
    - Sequence of GDValue
    - Set of GDValue
    - Map from GDValue to GDValue
    - each with an optional symbol identifying its type/role?

* Reasonably efficient memory usage, but no need to over-optimize
  - GDValue itself should be something like a 16-bit structure
  - Small integers do not require memory allocation
  - Symbols are represented as a pointer to a global symbol table, from
    which items are never removed (during the program lifetime)
  - STL containers of GDValue should be fine

* GDValues are *not* immutable, but the API protects those stored in
  sets and used as map keys from being modified.

* GDValues are totally ordered.

* GDValue exposes a hash code.

* Serialize and deserialize to text in a form vaguely like JSON.

* Serialize and deserialze to a compact binary form.


Data model
==========

The core concept of a Generalized Data Value is the "value".  A value is
one of the following:

  * Symbol: A (possibly-empty) finite sequence of Unicode code points.
    Symbols are distinct from strings, and intended to be names of
    entities or concepts with semantics specified elsewhere, rather than
    having intrinsic meaning.

  * Integer: Positive or negative integer, of unbounded but finite
    magnitude.  There is only one zero value (not both a positive and
    negative zero).

  * TODO: Add floats.

  * String: A finite sequence of Unicode code points.

  * Sequence: Also a finite ordered sequence of values.  In a sequence,
    the meaning of each element typically does not depend on its
    position.

  * Tuple: A finite ordered sequence of values.  In a tuple, the meaning
    of each element typically depends on its position.

  * Set: A finite unordered set of values.  An empty set is distinct
    from an empty sequence.

  * Map: A finite unordered map from values to values.  An empty map is
    a distinct value from an empty set or empty sequence.

  * Tagged container: A pair of a symbol and a sequence, set, or map.
    The tag indicates the kind of thing the container represents.

The meaning of a symbol is determined by mutual agreement between
producer and consumer; its meaning is extrinsic rather than intrinsic.
In this specification, it is encouraged for producers and consumers to
regard the following symbols as having pre-established reserved meaning:

  * null: An "absent" value, used in a context where a value is
    expected but no such value exists.

  * false: Boolean false.

  * true: Boolean true.

  * TODO: Nan, PInf, NInf.

The data model is meant to allow values to be totally ordered (that is,
for all values A and B, exactly one of A<B, A>B, and A==B is true)
within applications using it, but this specification does not prescribe
such an order, as this is just a passive data model without any defined
operations.


Data model rationale
====================

Symbols
-------

The inclusion of symbols distinct from strings is done to allow a
distinction between "data", the main thing being described and
manipulated, and "metadata", information related to the interpretation
of that data or the mechanism by which it is processed.  In the JSON
data model, these are conflated.  Consider:

  {
    "type": "diagram",
    "name": "boxes",
    "shapes": [],
    "customColors": {
      "red": "rgb(255,0,0)"
    }
  }

In the preceding, "name" is metadata.  It has extrinsic meaning, agreed
upon between producer and consumder.  In contrast, "boxes" is data with
intrinsic meaning.  It is a name assigned by the user; the program
does not treat it specially.

But then, in "customColors", we have a map where both the key and the
value are data.  The user of this hypothetical program can create an
arbitrary collection of custom color names with assigned RGB values;
"red" is not special.

In JSON, there is no distinction between strings used as data and those
used as metadata.  But of course real people find this distinction
important, so JSON is somewhat commonly used in a relaxed form that
allows unquoted keys, and people use unquoted keys to convey metadata.

Rather than forcing people to bend the rules to express their intent,
the GDV data model explicitly distinguishes strings from symbols, giving
them different syntax.

The choice to allow symbols to be arbitrary sequences of code points,
including the empty sequence, reflects that the meaning of those symbols
is *not* prescribed by the GDV data model.  It is up to the person
producing or consuming the data to decide what symbols mean, so the
model allows maximum flexibility.  Of course, in most situations it is
wise to select symbols that are convenient for humans to read and write,
but the data model does not insist on that.


The name "sequence"
-------------------

This model uses the name "sequence" to refer to a finite sequence.
There are several other plausible candidate terms that could have been
used for this role:

  * List

  * Array (the term used in JSON)

  * Vector

All of these have roots in mathematical literature.  However, when used
in a programming context, both "list" and "array" are closely associated
with particular data structures, whereas this data model is specifically
independent of any particular data structure realization, so those two
are rejected.

In mathematics, a vector need not consist of a sequence (a matrix can be
a vector) and has the algebraic properties that come with being a member
of a vector space.  Furthermore, in C++ at least, "vector" is closely
associated with an array-like data structure.

In contrast, the mathematical term "finite sequence" is a precise match
for the "sequence" of GDV, with little need in a programming context for
the "finite" qualifier.  Consequently, we use "sequence".

The one disadvantage of "sequence" is it is a slightly longer term than
is ideal for a concept that will be frequently used.  Fortunately, the
abbreviation "seq" is concise and unambiguous, so works well as a
substitute in cases where the longer term would get in the way.


Tuples versus sequences
-----------------------

The model includes both tuples (like "(1 2 3)") and sequences (like "[1
2 3]").  The reason is to better support the idea that the model is,
to some extent, self-describing.  That is, one can look at a value and
understand a lot about its intended purpose and meaning just from the
available structure, without reference to an external document.

In typical usage, a tuple is an object composed of several elements such
that the *position* of each element is important to interpreting that
element's meaning.  A good example is a date, e.g., "Date(2024 06 02)",
or a rational number, "Rational(3 5)".  These are not mere lists of
values that have an order, the exact position of each element is an
essential part of determining the element's meaning.

In contrast, while a sequence has an order (unlike a set), the precise
position of an element does not normally determine how that element is
interpreted.  That in turn *often* means that list elements are
"homogeneous" to some degree, but really what is decisive when choosing
a list over a tuple is whether you have to know the position to make
sense of the element.  Moreover, it is precisely the *ability* to convey
that distinction that I find compelling.

Considering the alternative of exclusively using sequences, I find
something like "[2024 06 02]" to be inadequate in an ostensibly
self-describing format, with "Date[2024 06 02]" clearly better but still
falling short of ideal.  Meanwhile, the cost of allowing one more kind
of container is very small in terms of mechanical concerns like parsing,
storing, and printing, and does not dramatically impact how the model is
serialized into less expressive forms like JSON, particularly given the
presence of tagged containers (discussed below).


Sets versus maps
----------------

In mathmatics, a map (or "function") is usually defined as a set of
tuples where every first element is unique.  This provides some economy
of reasoning since maps are not a distinct primitive and many of the
theorems that apply to sets also apply to maps.

It's therefore tempting to try to do the same for GDValue.  In
particular, the idea would be to say that a map is simply a set that
conforms to the requirement of all elements being two-element tuples
whose first elements are all unique within the map.

However, having pursued it a certain distance, there are several
problems:

  * It is fairly awkward to enforce the constraint.  Where exactly does
    the check go?  On every access that treats it as a map?  Upon some
    action that "imbues" it with map-like qualities?  And how does
    enforcement interact with modification?

  * If there is a notion of "imbuing" a set with map-like qualities,
    which seems like it might be needed to deal with the above, that
    will presumably be lost as soon as the map is serialized and
    deserialized.

  * That is, unless the serialization format also preserves that aspect,
    but then the text representation is different for maps and sets,
    which already undermines one of the presumptive advantages of the
    scheme to begin with.

  * The operations on the two are in fact fairly different.

Expanding on the last point, despite their constitutive structural
similarity, the way in which programs interact with sets and maps is
fairly different:

  Set                         Map
  --------------------        ------------
  insert E                    map K to V; deal with collision of K

  check if E is present       check if K (not (K,V)) is present

  remove E                    remove mapping for K (not (K,V))

                              get the V for a given K

  iterate over the Es;        iterate over (K,V); can change Vs
  cannot change any

This table lines up the major operations in rows of approximate
correspondence.  The semantically closest operation is insertion,
but even there maps have an issue with key collisions: they can
either (1) remove the old value or (2) ignore the insertion.  In
case 1, an entry that was previously present is now gone, while in
case 2, the entry the client inserted is *not* present after the
insertion.  Neither of those are possible with set insertion, where
everything that was already there remains, and the inserted element
is also assured to be there after the insertion.

The other operations have greater semantic differences, and sets do not
really have a counterpart to the map lookup operation.

Finally, iteration, while superficially similar, is arguably the
greatest and most problematic divergence.  When iterating over a set,
the client receives complete elements, but (typically, and for my
intended design) cannot modify the elements because doing so would
jeopardize the ordering invariant of the underlying data structure.  But
when iterating over a map, it is often (for example with C++ std::map)
allowed to modify the value.  Furthermore, the client interface
structurally ensures that it receives exactly (K,V) pairs, whereas when
iterating over a map as if it were a set, the client would receive
arbitrary values and have to check that they are two-element sequences,
doing something (what exactly?) when they are not.

Consequently, in this design, I simply treat sets and maps as entirely
different, unrelated containers.


Tagged containers
-----------------

Tagged containers allow consumers to easily recognize what kind of thing
a container represents without having to inspect either its context or
contents.  This is another feature that advances the goal of being
self-describing.  Because it is so useful, many JSON formats include a
provision for a "type" or similar field in a map to indicate the entity
kind, but that is awkward (since it is in the wrong place), and
impossible for lists.  An alternative is to wrap a two-element list
around the outside, but that is a weak convention to try to follow and
creates significant additional delimiter clutter.

Tagged containers have some arguable precedent in s-expressions, where
one might see "(Date 2024 06 24)", and this prompts the question of why
not follow that example.  In sort, that syntax puts the symbol ("Date")
on the wrong side of the delimiter.  Syntactically it is symmetric with
the following elements, but semantically plays an entirely different
role.  By swapping them, "Date(2024 06 24)", the syntax reflects the
role.

As further elaboration, consider three alternative data models:

* Java/C++/etc.: Objects have (class) names, fields have names.

* JSON: Fields have names, objects do not.

* XML: Elements (analogous to objects) have names, while sub-elements
  (analogous to fields) do not.  XML also has named attributes, but
  these are not recursive (an attribute cannot contain an element).

The data models used by JSON and XML each drop one kind of name that a
conventional programming language like Java or C++ has in its data
model.  Names are the most fundamental and important abstraction
mechanism in data modeling, and their loss is acutely felt in practical
use of both JSON and XML, and people respond by contorting the
respective models to shoehorn the missing names in various ways.  The
GDV data follows the programming language examples by allowing names to
be easily associated both with container and containee, but does not
require either.


GDVN: Text representation
=========================

The text form, called GDVN for General Data Value Notation, is intended
to be superset of JSON (as described in RFC 8259), but is nevertheless
independently specified here.

GDVN is a textual format, regarded as a sequence of Unicode code points.
In principle any encoding can be used, but in practice UTF-8 encoding is
strongly preferred.

Symbols have two forms, unquoted and quoted:

  * An unquoted symbol conforms to the regex: [a-zA-Z_][a-zA-Z0-9_]

    This includes symbols that are expected to have ubiquitous special
    meaning such as "null", "true", and "false".  The syntax simply
    treats them uniformly as symbols.

    TODO: I would like to allow arbitrary Unicode "letters" and
    "digits" in the unquoted form.

  * A quoted symbol begins and ends with backtick '`', and in between
    has the same set of escape codes as double-quoted strings (see
    below).

Integers have the form <sign?><radix?><digits> where:

  * <sign?> is either "" or "-", the latter indicating a negative
    number.  It *is* allowed to use "-" when the magnitude is zero, but
    this is semantically equivalent to omitting the "-".

  * <radix?> is "0x", "0o", or "0b", indicating hexadecimal, octal, or
    binary, respectively.  The letter can be uppercase or lowercase.

  * <digits> is a non-empty sequence of digits consistent with the
    specified base, or decimal of there is no radix indicator.  It can
    have extra leading zeroes, but they are semantically insignificant;
    in particular, a leading zero does *not* indicate to use octal.
    Hexadecimal digits A-F can be uppercase or lowercase.

TODO: Specify a form for floating-point numbers.

A double-quoted string is as in JSON, with a few extensions:

  * It begins and ends with '"'.

  * In the string, all unicode code points are allowed, and represent
    themselves, except:
    * DoubleQuote: "
    * Backslash: \
    * Code points less than decimal 32 (space)

  * One of the recognized two-character escape sequences:
    * \"     DoubleQuote
    * \\     Backslash aka Reverse Solidus
    * \/     Slash aka Solidus
    * \b     Backspace (dec 8)
    * \f     FormFeed (dec 12)
    * \n     LineFeed (dec 10)
    * \r     CarriageReturn (dec 13)
    * \t     Tab (dec 9)
    * \'     Single quote   # extension of JSON
    * \`     Backtick       # extension of JSON

  * \uNNNN where N are hex to denote UTF-16 code unit in [0,0xFFFF].
    If the code unit is a surrogate element, it must be part of a
    well-formed surrogate pair.  Otherwise it directly denotes a code
    point.

  * \u{N+} where N+ is a non-empty sequence of hex digits denoting a
    Unicode code point in [0,0x10FFFF].  There is no limit on the number
    of digits (there can be any number of leading 0s while adhering to
    the value constraint).

  * Any other character following backlash is an *error* and must be
    rejected by the GDVN parser.

Some code points have multiple representations, for example backslash
can be written as "\\" or as "\u005c".  These two forms are semantically
equivalent.

  TODO: I'd like to allow string continuation with "+".

TODO: Octet sequences are, perhaps, like in Python.

Whitespace: All of the following are treated as whitespace:

  * Space
  * Tab
  * LineFeed
  * CarriageReturn
  * Comma ','       see Rationale section.

Whitespace separates values within a container and optionally separates
the container delimiters from values inside them.

Sequence: [1 2 3]

  Note that there is no punctuation between values.  Separators are not
  needed for parsing disambiguation, can contribute visual clutter
  (although sometimes they help with that too, it varies), and are
  annoying to deal with if not allowed at the end, while being somewhat
  ugly when they are.

Tuple: (1 2 3)

  The rules are the same as for sequences, except using round
  parentheses instead of square brackets.

Set: {{1 2 3}}

  There is no significance to the order in which elements appear.  The
  notations "{{1 2}}" and "{{2 1}}" are equivalent, just like the
  notations "{{1 2}}" and "{{1  2}}" (with an extra space) are
  equivalent.  Implementations should *not* preserve the serialization
  order among set elements unless they are also preserving (say)
  whitespace and comments, which is to say, they are implementing a
  fundamentally different data model than what GDValue specifies.

  Duplicate elements are *ignored*.  The notation "{{1 1}}" is
  equivalent to the notation "{{1}}".

Map: {a:1 b:2 c:3}

  After the opening brace, the format allows a value, which must be
  followed by a colon, possibly preceded by whitespace.  The end of a
  value is always unambiguous given one character of lookahead, and the
  parser will know it is parsing a map entry from the start, so the
  separating colon does not present parsing difficulties.

  There is no significance to the order in which map entries appear.

  It is an *error* for a map to have two identical keys, even if their
  values are also identical.

    {a:1 a:1}     # syntax error

  Note: Map keys (and values) are arbitrary values, including strings,
  symbols that have denote special values, and other maps, for example:

    {a:1 "b":2 {m:three}:3 {{s four}}:4 (v five):5
     null:6 true:7 123:8 -456:9 {x:y z:w}:{d:e f:g}}

  Typically, a map that represents an "object", i.e., a heterogeneous
  tuple with elements that have named, pre-assigned roles, would use
  symbols as keys, while a map that represents a true map from the end
  user's perspective would use other sorts of values (especially
  strings) as keys, but the data model and format do not impose any
  constraint in that regard.

  There is a parsing non-determinism when there are two consecutive open
  braces.  This is resolved by saying each consecutive pair of braces,
  after all previous braces have been accounted for, is the start of a
  *set*, not a map:

    {{A}}                # set containing A
    {{{{1 2}}}}          # set containing set containing 1 and 2
    { {1:2}:3}           # map from {1:2} to 3
    {{1:2}:3}            # syntax error: colon after set element 1
    {{{1:2}}}            # set containing map from 1 to 2
    {{}}                 # empty set
    {}                   # empty map
    {{{{{1:2}}}}}        # set containing set containing map from 1 to 2

  As a consequence of this disambiguation rule, when the first key (in a
  given serialization) of a map is another map, it is necessary to
  insert at least one space after the outer map's opening brace (as
  shown above in the third example).

Tagged container: Tag[...] or Tag{{...}} or Tag{...}

  If the character immediately following a symbol, with no intervening
  whitespace, is '[' or '{', then the symbol is combined with the
  following container into a "tagged container".

For all values, if their last character is not the last character in the
file, then the following character must be one of:

  * Whitespace, including ','
  * '}'
  * ']'
  * ')'
  * ':'

Consequently, for example, "[1a]" is invalid, whereas without this rule,
it could potentially be parsed the same as "[1 a]".


GDVN Rationale
==============

The biggest choice is to be a superset of JSON.  The rationale is fairly
simple: lots of software can produce and consume JSON already, so this
faciliates interoperability.  It also makes it easier for people to
learn since the foundation is well known.  JSON brings some baggage,
such as tolerating UTF-16 surrogate code pairs in strings, but this is a
small price to pay.

An unusual choice is to regard the comma character as "whitespace" since
it obviously isn't "white" (graphically invisible).  Commas are a
persistent thorn in the side of JSON, being annoying to produce when not
allowed in the trailing position and often ugly regardless.  They are
not necessary for parsing, so originally GDVN did not have them at all.
I then decided that allowing but ignoring them would let GDVN be a JSON
superset, which is valuable.  But "canonical" GDVN does not use them.

The common symbols "null", "true", and "false" are not special because
they do not need to be.  Whether and how applications give them special
semantics is entirely up to those applications.  Furthermore, this
allows additional symbols such as "NaN", "PInf", and "NInf" to be used
as alternatives to ordinary floating point numbers once floats are
added.

Quoted symbols are enclosed in backticks because this is becoming a
common way to write symbol-like entities in general text due to the
influence of Markdown.  Single-quote remain unused (and hence reserved)
for possible future extension of the format.

The notation for integers allows radix specifiers (unlike JSON) in part
to allow large integers to be expressed as hexadecimal, which is much
more efficient since conversion from an internal binary representation
to decimal digits requires repeated division by 10.  It does not follow
the C/C++ convention of using a leading zero to indicate octal because
that is octal is rare, and that notation is obscure and confusing to
those only familiar with mathematical notation.  It allows redundant
leading zeroes in part because standard mathematical notation does, and
in part to allow situation-specific flexibility in formatting.  For
example, "[1980 01 31]" is much better than "[1980 1 31]" for writing a
date since only the former fits the ISO-8601 YYYY-MM-DD form (albeit
without the hyphens).

Within strings, unknown baskslash codes are disallowed in order to
reserve them for possible future use.  If instead, say, "\c" just meant
"c", then there would be no room to expand without breaking backward
compatibility.

GDVN adds "\'" and "\`" codes that JSON does not have.  The latter is of
course to ensure the escape codes are uniform inside strings and
symbols.  The former anticipates possibly using single-quoted strings
for some future purpose, and acknowledges that it would be surprising if
"\'" were ever given a meaning *other than* single-quote.

GDVN adds "\u{N+}" from C++23, originally described in P2290R3:

  https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2290r3.pdf

The rationale is basically the same, that "\u" cannot express the entire
range (without surrogates) and "\U" is awkwardly long.  "\u{N+}" allows
a uniform notation from "\u{0}" (already one character shorter than
"\u0000") to "\u{10FFFF}", while also permitting "\u{0010FFFF}" if
someone likes digit counts that are a power of 2.

Using doubled braces for sets is imperfect, but using single braces is
bad because then an empty set could not be distinguished from an empty
map, and no other choice seemed acceptable.  The single braces are
reserved for maps because they are more common and important in
practice, and that is what JSON uses.

Duplicated elements in sets are ignored because this conforms to the
usual mathematical notion for sets.  Furthermore, rejecting a set
denoted with duplicate elements is unlikely to reveal latent bugs, nor
would it preserve a useful syntax extension point for the future, and it
could be useful in some streaming data scenarios.

For maps, the choice of compact notation is motivated (beyond JSON
compatibility) by the observation of the paramount role that maps play
in data interchange.  This is what people will mostly be looking at, so
is the case to optimize, even at the expense of slight irregularity (by
which I mean choosing to use "a:1" instead of "[a 1]", which would
otherwise be the notation for a pair in the GDV system).

Duplicated map keys are rejected because a duplicated map key *is*
likely to indicate a problem in the upstream production of the data,
silently dropping one of two different values (which one?) would be
quite surprising and constitute potential data loss, and that policy is
extended to the case of identical values for uniformity.

The restriction on what characters can follow a value, which has the
effect of preventing values from being juxtaposed, is meant in part to
ensure readability, and also to preserve future extension points.


The double-brace conflict
=========================

Although this specification currently resolves the double-brace conflict
by requiring a map whose first key is a map to be written with
separating whitespace, this is not strictly necessary.  That is, there
is not a true grammatical ambiguity.  In particular, the following
parsing strategy would work:

1. When consecutive left braces are seen uninterrupted by whitespace,
   count them.  Let N be the current number of unresolved consecutive
   left-braces.

     Example: After "{{{{{", N is 5.

2. After consecutive left braces, if what follows is a single
   right-brace, that must be the closing delimiter of an empty map, so
   reduce N by one and regard the empty map as a value in step 3.

     Example: "{{{{{} " -> "{{{{<emptymap>", N is 4.

3. After consecutive left braces, if what follows is a value:

   3a. If the value is followed by a colon, that must be a map key.
       Finish parsing the map to its closing delimiter, reduce N by one,
       and treat the map as the value for step 3.

         Example: "{{{{{3:" -> parse map -> "{{{{<map>", N is 4.

   3b. If the value is followed by another value or a close-brace, then
       it must be a set element.  Finish parsing the set to its
       double-brace closing delimiter, reduce N by 2, and treat the set
       as a value for step 3.  It is a syntax error if N is only 1 at
       this point.

         Example: "{{{{{3 4" -> parse set -> "{{{<set>", N is 3.
         Example: "{{{{{3}"  -> eat "}"   -> "{{{<set>", N is 3.

4. After consecutive left braces, if what follows is at least two
   right-braces, they must be the closing delimiter of an empty set, so
   reduce N by 2 and regard the empty set as the value in step 3.  It
   is a syntax error if N is only 1.

     Example: "{{{{{}}" -> "{{{<set>", N is 3.

Despite the existence of this parsing strategy, I have chosen to require
that the left-braces of a map not be consecutive to ease the
implementation of a parser, as the cost in irregularity is minimal.


Mapping to JSON
===============

If we have a GDV value that we want to express as JSON, how should we do
so?  This section suggests a mapping.

Symbol

  GDVN: foo

  JSON: { "_type": "symbol", "name": "foo" }

Integer

  GDVN: 123

  If small enough to represent exactly as a 64-bit float:

    JSON: 123

  If too large:

    JSON: { "_type": "large_integer", "value": "123" }

String: Same representation.

Sequence: Same representation.

Set

  GDVN: {{1 2}}

  JSON: { "_type": "set", "elements": [1, 2] }

Map

  If all of the keys are strings:

    GDVN: {"a":1 "b":2}

    JSON: {"a":1, "b":2}

  If some keys are not strings:

    GDVN: {1:2 3:4}

    JSON: { "_type": "map", "entries": [[1, 2], [3, 4]] }

Tagged sequence:

  GDVN: Foo[1 2]

  JSON: { "_type": "sequence", "tag": "Foo", "elements": [1, 2] }

Tagged set:

  GDVN: Foo{{1 2}}

  JSON: { "_type": "set", "tag": "Foo", "elements": [1, 2] }

Tagged map:

  GDVN: Foo{"a":1}

  JSON: { "_type": "map", "tag": "Foo", "entries": [["a", 1]] }


EOF
