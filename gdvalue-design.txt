gdvalue-design.txt
==================


Goals
=====

* Have a C++ class, 'GDValue', that can store a variety of useful data
  types as a discriminated union:
  - Absent value
  - Boolean
  - Number
    - Arbitrary-precision integer
    - Floating-point number?
  - String-like
    - Symbol: strings that represent names of things or concepts
    - String: sequence of Unicode code points
    - Octet array
  - Container
    - Tuple?
    - Sequence of GDValue
    - Set of GDValue
    - Map from GDValue to GDValue
    - each with an optional symbol identifying its type/role?

* Reasonably efficient memory usage, but no need to over-optimize
  - GDValue itself should be something like a 16-bit structure
  - Small integers do not require memory allocation
  - Symbols are represented as a pointer to a global symbol table, from
    which items are never removed (during the program lifetime)
  - STL containers of GDValue should be fine

* GDValues are *not* immutable, but the API protects those stored in
  sets and used as map keys from being modified.

* GDValues are totally ordered.

* GDValue exposes a hash code.

* Serialize and deserialize to text in a form vaguely like JSON.

* Serialize and deserialze to a compact binary form.


Sets versus maps
================

In mathmatics, a map (or "function") is usually defined as a set of
tuples where every first element is unique.  This provides some economy
of reasoning since maps are not a distinct primitive and many of the
theorems that apply to sets also apply to maps.

It's therefore tempting to try to do the same for GDValue.  In
particular, the idea would be to say that a map is simply a set that
conforms to the requirement of all elements being two-element vectors
(as I do not have a distinct "pair" or even "tuple" notion) whose first
elements are all unique within the map.

However, having pursued it a certain distance, there are several
problems:

  * It is fairly awkward to enforce the constraint.  Where exactly does
    the check go?  On every access that treats it as a map?  Upon some
    action that "imbues" it with map-like qualities?  And how does
    enforcement interact with modification?

  * If there is a notion of "imbuing" a set with map-like qualities,
    which seems like it might be needed to deal with the above, that
    will presumably be lost as soon as the map is serialized and
    deserialized.

  * That is, unless the serialization format also preserves that aspect,
    but then the text representation is different for maps and sets,
    which already undermines one of the presumptive advantages of the
    scheme to begin with.

  * The operations on the two are in fact fairly different.

Expanding on the last point, despite their constitutive structural
similarity, the way in which programs interact with sets and maps is
fairly different:

  Set                         Map
  --------------------        ------------
  insert E                    map K to V; deal with collision of K

  check if E is present       check if K (not (K,V)) is present

  remove E                    remove mapping for K (not (K,V))

                              get the V for a given K

  iterate over the Es;        iterate over (K,V); can change Vs
  cannot change any

This table lines up the major operations in rows of approximate
correspondence.  The semantically closest operation is insertion,
but even there maps have an issue with key collisions: they can
either (1) remove the old value or (2) ignore the insertion.  In
case 1, an entry that was previously present is now gone, while in
case 2, the entry the client inserted is *not* present after the
insertion.  Neither of those are possible with set insertion, where
everything that was already there remains, and the inserted element
is also assured to be there after the insertion.

The other operations have greater semantic differences, and sets do not
really have a counterpart to the map lookup operation.

Finally, iteration, while superficially similar, is arguably the
greatest and most problematic divergence.  When iterating over a set,
the client receives complete elements, but (typically, and for my
intended design) cannot modify the elements because doing so would
jeopardize the ordering invariant of the underlying data structure.  But
when iterating over a map, it is often (for example with C++ std::map)
allowed to modify the value.  Furthermore, the client interface
structurally ensures that it receives exactly (K,V) pairs, whereas when
iterating over a map as if it were a set, the client would receive
arbitrary values and have to check that they are two-element vectors,
doing something (what exactly?) when they are not.

Consequently, in this design, I simply treat sets and maps as entirely
different, unrelated containers.


GDVN: Text representation
=========================

The text form, called GDVN for General Data Value Notation, is intended
to be superset of JSON (as described in RFC 8259), but is nevertheless
independently specified here.

GDVN is a textual format, regarded as a sequence of Unicode code points.
In principle any encoding can be used, but in practice UTF-8 encoding is
strongly preferred.

The absent value is 'null'.  Syntactically, 'null' is a symbol, but it
has special meaning.

Booleans are 'true' and 'false'.

Integers use the regex: (0|-?([1-9][0-9]+))

TODO: Specify a form for floating-point numbers.

Symbols use the regex: [a-zA-Z_][a-zA-Z0-9_]

  TODO: Ideally I would extend this to any unicode sequence that has
  similar starting and continuation conditions.

A double-quoted string is as in JSON:

  * It begins and ends with '"'.

  * In the string, all unicode code points are allowed, and represent
    themselves, except:
    * DoubleQuote: "
    * Backslash: \
    * Code points less than decimal 32 (space)

  * One of the recognized two-character escape sequences:
    * \"     DoubleQuote
    * \\     Backslash aka Reverse Solidus
    * \/     Slash aka Solidus
    * \b     Backspace (dec 8)
    * \f     FormFeed (dec 12)
    * \n     LineFeed (dec 10)
    * \r     CarriageReturn (dec 13)
    * \t     Tab (dec 9)

  * \uNNNN where N are hex to denote UTF-16 code unit in [0,0xFFFF].
    If the code unit is a surrogate element, it must be part of a
    well-formed surrogate pair.  Otherwise it directly denotes a code
    point.

  * Any other character following backlash is an *error* and must be
    rejected by the GDVN parser.

Some code points have multiple representations, for example backslash
can be written as "\\" or as "\u005c".  These two forms are semantically
equivalent.

  TODO: I'd like to allow string continuation with "+".

TODO: Octet sequences are, perhaps, like in Python.

Whitespace: All of the following are treated as whitespace:

  * Space
  * Tab
  * LineFeed
  * CarriageReturn
  * Comma ','       see Rationale section.

Whitespace separates values within a container and optionally separates
the container delimiters from values inside them.

Vector: [1 2 3]

  Note that there is no punctuation between values.  Separators are not
  needed for parsing disambiguation, can contribute visual clutter
  (although sometimes they help with that too, it varies), and are
  annoying to deal with if not allowed at the end, while being somewhat
  ugly when they are.

Set: {{1 2 3}}

  There is no significance to the order in which elements appear.  The
  notations "{{1 2}}" and "{{2 1}}" are equivalent, just like the
  notations "{{1 2}}" and "{{1  2}}" (with an extra space) are
  equivalent.  Implementations should *not* preserve the serialization
  order among set elements unless they are also preserving (say)
  whitespace and comments, which is to say, they are implementing a
  fundamentally different data model than what GDValue specifies.

  Duplicate elements are *ignored*.  The notation "{{1 1}}" is
  equivalent to the notation "{{1}}".

Map: {a:1 b:2 c:3}

  After the opening brace, the format allows a value, which must be
  followed by a colon, possibly preceded by whitespace.  The end of a
  value is always unambiguous given one character of lookahead, and the
  parser will know it is parsing a map entry from the start, so the
  separating colon does not present parsing difficulties.

  There is no significance to the order in which map entries appear.

  It is an *error* for a map to have two identical keys, even if their
  values are also identical.

    {a:1 a:1}     # syntax error

  Note: Map keys (and values) are arbitrary values, including strings,
  symbols that have denote special values, and other maps, for example:

    {a:1 "b":2 {m:three}:3 {{s four}}:4 (v five):5
     null:6 true:7 123:8 -456:9 {x:y z:w}:{d:e f:g}}

  Typically, a map that represents an "object", i.e., a heterogeneous
  tuple with elements that have named, pre-assigned roles, would use
  symbols as keys, while a map that represents a true map from the end
  user's perspective would use other sorts of values (especially
  strings) as keys, but the data model and format do not impose any
  constraint in that regard.

  There is a parsing non-determinism when there are two consecutive open
  braces.  This is resolved by saying each consecutive pair of braces,
  after all previous braces have been accounted for, is the start of a
  *set*, not a map:

    {{A}}                # set containing A
    {{{{1 2}}}}          # set containing set containing 1 and 2
    { {1:2}:3}           # map from {1:2} to 3
    {{1:2}:3}            # syntax error: colon after set element 1
    {{{1:2}}}            # set containing map from 1 to 2
    {{}}                 # empty set
    {}                   # empty map
    {{{{{1:2}}}}}        # set containing set containing map from 1 to 2

  As a consequence of this disambiguation rule, when the first key (in a
  given serialization) of a map is another map, it is necessary to
  insert at least one space after the outer map's opening brace (as
  shown above in the third example).


GDVN Rationale
==============

The biggest choice is to be a superset of JSON.  The rationale is fairly
simple: lots of software can produce and consume JSON already, so this
faciliates interoperability.  It also makes it easier for people to
learn since the foundation is well known.  JSON brings some baggage,
such as tolerating UTF-16 surrogate code pairs in strings, but this is a
small price to pay.

An unusual choice is to regard the comma character as "whitespace" since
it obviously isn't "white" (graphically invisible).  Commas are a
persistent thorn in the side of JSON, being annoying to produce when not
allowed in the trailing position and often ugly regardless.  They are
not necessary for parsing, so originally GDVN did not have them at all.
I then decided that allowing but ignoring them would let GDVN be a JSON
superset, which is valuable.  But "canonical" GDVN does not use them.

Within strings, unknown baskslash codes are disallowed in order to
reserve them for possible future use.  If instead, say, "\c" just meant
"c", then there would be no room to expand without breaking backward
compatibility.

Using doubled braces for sets is imperfect, but using single braces is
bad because then an empty set could not be distinguished from an empty
map, and no other choice seemed acceptable.  The single braces are
reserved for maps because they are more common and important in
practice, and that is what JSON uses.

Duplicated elements in sets are ignored because this conforms to the
usual mathematical notion for sets.  Furthermore, rejecting a set
denoted with duplicate elements is unlikely to reveal latent bugs, nor
would it preserve a useful syntax extension point for the future, and it
could be useful in some streaming data scenarios.

For maps, the choice of compact notation is motivated (beyond JSON
compatibility) by the observation of the paramount role that maps play
in data interchange.  This is what people will mostly be looking at, so
is the case to optimize, even at the expense of slight irregularity (by
which I mean choosing to use "a:1" instead of "[a 1]", which would
otherwise be the notation for a pair in the GDV system).

Duplicated map keys are rejected because a duplicated map key *is*
likely to indicate a problem in the upstream production of the data,
silently dropping one of two different values (which one?) would be
quite surprising and constitute potential data loss, and that policy is
extended to the case of identical values for uniformity.


The double-brace conflict
=========================

Although this specification currently resolves the double-brace conflict
by requiring a map whose first key is a map to be written with
separating whitespace, this is not strictly necessary.  That is, there
is not a true grammatical ambiguity.  In particular, the following
parsing strategy would work:

1. When consecutive left braces are seen uninterrupted by whitespace,
   count them.  Let N be the current number of unresolved consecutive
   left-braces.

     Example: After "{{{{{", N is 5.

2. After consecutive left braces, if what follows is a single
   right-brace, that must be the closing delimiter of an empty map, so
   reduce N by one and regard the empty map as a value in step 3.

     Example: "{{{{{} " -> "{{{{<emptymap>", N is 4.

3. After consecutive left braces, if what follows is a value:

   3a. If the value is followed by a colon, that must be a map key.
       Finish parsing the map to its closing delimiter, reduce N by one,
       and treat the map as the value for step 3.

         Example: "{{{{{3:" -> parse map -> "{{{{<map>", N is 4.

   3b. If the value is followed by another value or a close-brace, then
       it must be a set element.  Finish parsing the set to its
       double-brace closing delimiter, reduce N by 2, and treat the set
       as a value for step 3.  It is a syntax error if N is only 1 at
       this point.

         Example: "{{{{{3 4" -> parse set -> "{{{<set>", N is 3.
         Example: "{{{{{3}"  -> eat "}"   -> "{{{<set>", N is 3.

4. After consecutive left braces, if what follows is at least two
   right-braces, they must be the closing delimiter of an empty set, so
   reduce N by 2 and regard the empty set as the value in step 3.  It
   is a syntax error if N is only 1.

     Example: "{{{{{}}" -> "{{{<set>", N is 3.

Despite the existence of this parsing strategy, I have chosen to require
that the left-braces of a map not be consecutive to ease the
implementation of a parser, as the cost in irregularity is minimal.














EOF
