#!/usr/bin/perl -w
# encode a file's contents as a C string literal

use strict;

# This script reads an arbitrary source file, and produces as output
# C/C++ source code that defines a string literal with the same
# contents as the source file.  This allows what would otherwise be
# separate files to be compiled into an executable, easing deployment.

sub usage {
  print(<<"EOF");
usage: $0 <arrayName> <inFile> <outHeader> <outCode>

Reads <inFile>, writes <outHeader> and <outCode>.
<outHeader> declares a char array called <arrayName>.
<outCode> defines that char array.

EOF
}

if (@ARGV != 4) {
  usage();
  die("script must be called with exactly 4 arguments\n");
}

my ($arrayName, $inFile, $outHeader, $outCode) = @ARGV;


# -------------------------- reading ----------------------------
open(IN, "<$inFile") or die("cannot read $inFile: $!\n");
binmode(IN);

# lines of encoded characters
my @outLines = ();

# current encoded output line
my $curOutLine = "";

# total number of characters
my $numCharacters = 0;

while (1) {
  my $buf;
  my $len = read(IN, $buf, 4096);

  if (!defined($len)) {
    die("$inFile: read failed: $!\n");
  }

  if ($len == 0) {
    last;
  }

  $numCharacters += $len;

  for (my $i=0; $i < $len; $i++) {
    my $s = substr($buf, $i, 1);
    my $n = ord($s);

    if ($n == 10) {
      # at newlines, encode it and also break the string literal
      # so that the output is not all on one line
      $curOutLine .= "\\n";
      push @outLines, ($curOutLine);
      $curOutLine = "";
    }

    elsif ($s eq "\"") {
      $curOutLine .= "\\\"";
    }

    elsif ($s eq "\\") {
      $curOutLine .= "\\\\";
    }

    elsif (32 <= $n && $n < 127) {
      # ordinary printing character
      $curOutLine .= $s;
    }

    else {
      # encode as hex
      $curOutLine .= sprintf("\\x%02X", $n);
    }
  }
}

# final line; might be empty, which is fine, and handles the
# degenerate case of an empty input file
push @outLines, ($curOutLine);

close(IN) or die;


# Size of the output array.  It is one more than the source file's
# size because (a) the array literal syntax requires an implicit NUL
# byte at the end (C++03 8.5.2/2), and (b) it is often convenient
# to have the extra NUL anyway, so the contents can be used with
# standard string-manipulation functions.  When dealing with binary
# data, clients must be aware that the extra NUL byte is always
# present, and was not in the original file.
my $arraySize = $numCharacters + 1;


# ---------------------- write header ----------------------------
open(OUT, ">$outHeader") or die("cannot write $outHeader: $!\n");

# name of the #inclusion guard symbol: uppercase, with non-alnum
# replaced with underscores
my $guardName = uc($outHeader);
$guardName =~ s/[^A-Z0-9]/_/g;

print OUT (<<"EOF");
// $outHeader
// header file generated by $0 @ARGV

#ifndef $guardName
#define $guardName

// contents of $inFile, plus an extra NUL byte
extern char const $arrayName\[$arraySize\];

#endif // $guardName
EOF


close(OUT) or die;


# ----------------------- write code -----------------------------
open(OUT, ">$outCode") or die("cannot write $outCode: $!\n");

print OUT (<<"EOF");
// $outCode
// code file generated by $0 @ARGV

#include "$outHeader"             // decl of $arrayName

// contents of $inFile, plus an extra NUL byte
char const $arrayName\[$arraySize\] =
EOF

foreach my $encLine (@outLines) {
  print OUT ("  \"$encLine\"\n");
}

print OUT (<<"EOF");
  ;

// EOF
EOF


print("encoded $numCharacters bytes in $outHeader and $outCode\n");

exit(0);


# EOF
